#include <Kokkos_Core.hpp>
#include <biocma_cst_config.hpp>
#include <common/execinfo.hpp>
#include <common/logger.hpp>
#include <core/case_data.hpp>
#include <core/global_initaliser.hpp>
#include <host_specific.hpp>
#include <impl_post_process.hpp>
#include <ios>
#include <memory>
#include <optional>
#include <ostream>
#include <serde.hpp>
#include <simulation/feed_descriptor.hpp>
#include <simulation/simulation.hpp>
#include <sstream>
#include <string>
#include <utility>
#include <worker_specific.hpp>

#ifndef NO_MPI
#  include <mpi_w/wrap_mpi.hpp>
#endif

namespace Core
{

  std::string exporter_filename(const ExecInfo& exec,
                                const SimulationParameters& params)
  {
    std::stringstream filename;
    filename << params.results_file_name << "_partial_" << exec.current_rank
             << ".h5";
    return filename.str();
  }

  void init_partial_exporter(Core::PartialExporter& partial_exporter,
                             const CaseData& case_data)
  {
    const auto [_, n_compartment] = case_data.simulation->getDimensions();
    partial_exporter.init_fields(case_data.params.number_exported_result,
                                 n_compartment);
    auto probes = Simulation::ProbeAutogeneratedBuffer();
    case_data.simulation->setProbes(std::move(probes));
    partial_exporter.write_number_particle(
        case_data.simulation->mc_unit->getRepartition());
    PostProcessing::save_particle_state(*case_data.simulation,
                                        partial_exporter);
  }

  void exec(std::shared_ptr<IO::Logger> logger, CaseData&& case_data)
  {
    // TODO Find orphan profile_section : Kokkos::Profiling::popRegion() called
    // outside  of an actve region. Previous regions:

#ifdef NO_MPI
    const auto f_run = host_process;
#else
    const auto f_run = (case_data.exec_info.current_rank == 0)
                           ? &host_process
                           : &workers_process;
#endif

    const auto filename =
        exporter_filename(case_data.exec_info, case_data.params);
    Core::PartialExporter partial_exporter(ExecInfo(), filename);
    init_partial_exporter(partial_exporter, case_data);
    partial_exporter.set_logger(logger);
    auto* const sim = case_data.simulation.get();

    f_run(logger,
          case_data.exec_info,
          *sim,
          case_data.params,
          std::move(case_data.transitioner),
          partial_exporter);

    if constexpr (AutoGenerated::FlagCompileTime::use_probe)
    {
      PostProcessing::save_probes(*sim, partial_exporter, true);
    }
    if (case_data.params.save_final_serde)
    {
      // Load/Save works fine but be careful with big data (can crash due to
      // overflow) mainly on GPU
      if constexpr (AutoGenerated::FlagCompileTime::use_cereal_serde)
      {
        do_serde(case_data);
      }
      else
      {
        logger->alert("CaseData",
                      "Saving final results are requested but no serde "
                      "implementation was given");
      }
    }

    case_data.simulation->mc_unit.reset();
  }

  std::optional<Core::CaseData>
  load(const ExecInfo& exec,
       const UserControlParameters&& params,
       std::optional<Simulation::Feed::SimulationFeed> feed)
  {
    return impl_load(
        exec, std::forward<decltype(params)>(params), std::move(feed));
  }

  ExecInfo
  runtime_init(int argc, char** argv, std::optional<std::size_t> force_run_id)
  {
    ExecInfo info{};

    int rank = 0;
    int size = 1;
    if constexpr (AutoGenerated::FlagCompileTime::use_mpi)
    {
#ifndef NO_MPI
      if (!WrapMPI::is_initialized())
      {
        // MPI_Init(&argc, &argv);
        MPI_Init(NULL, NULL); // FIXME with python API
      }
      MPI_Comm_rank(MPI_COMM_WORLD, &rank);
      MPI_Comm_size(MPI_COMM_WORLD, &size);

#endif
    }
    if (!Kokkos::is_finalized() && !Kokkos::is_initialized())
    {
      Kokkos::initialize(argc, argv);
    }

#ifndef NO_MPI
    WrapMPI::barrier();
#endif

    if (rank == 0)
    {
      if constexpr (AutoGenerated::FlagCompileTime::verbose)
      {
        std::ostream& out_stream = std::cout;
        std::stringstream os;
        Kokkos::print_configuration(os, true);
        std::string line;
        std::ios_base::sync_with_stdio(false);
        while (std::getline(os, line))
        {
          out_stream << IO::AnsiCode::green
                     << "[Kokkos]: " << IO::AnsiCode::reset << line << '\n';
        }
        if constexpr (AutoGenerated::FlagCompileTime::use_mpi)
        {
          out_stream << IO::AnsiCode::green << "[Host]: " << IO::AnsiCode::reset
                     << "Number of MPI nodes: " << size << '\n';
        }
        std::ios_base::sync_with_stdio(true);
        std::flush(std::cout);
      }
    }

    if constexpr (AutoGenerated::FlagCompileTime::use_mpi)
    {
#ifndef NO_MPI
      std::atexit(WrapMPI::finalize);
#endif
    }

    info.current_rank = static_cast<size_t>(rank);
    info.n_rank = static_cast<size_t>(size);

    info.thread_per_process = Kokkos::num_threads();

    const auto id_seed = (force_run_id.has_value())
                             ? *force_run_id
                             : static_cast<size_t>(time(nullptr) * info.n_rank *
                                                   info.thread_per_process);

    std::string s = std::to_string(id_seed);
    info.run_id = std::hash<std::string>{}(s);

    return info;
  }

} // namespace Core
