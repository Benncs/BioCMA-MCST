#include "biocma_cst_config.hpp"
#include "common/common.hpp"
#include "dataexporter/data_exporter.hpp"
#include "models/two_meta_nb.hpp"
#include <dataexporter/partial_exporter.hpp>
#include <optional>
#include <utility>
#include <vector>

namespace Core
{
  PartialExporter::PartialExporter(
      const ExecInfo& info,
      std::string_view _filename,
      std::optional<export_metadata_t> user_description)
      : DataExporter(info, _filename, std::move(user_description)),
        probe_counter_n_element(0)
  {
    write_properties(std::nullopt, metadata);
  }

  void PartialExporter::init_fields(uint64_t n_iter, uint64_t n_compartments)
  {
    std::vector<unsigned long long> chunk = {1, n_compartments};
    const uint64_t n_expected_export = n_iter + 2; // Add first + last
    MultiMatrixDescription particle_repartition = {
        .name = "records/number_particle",
        .dims = {1, n_compartments},
        .max_dims = {n_expected_export, n_compartments},
        .chunk_dims = chunk,
        .compression = true,
        .is_integer = true};

    this->prepare_matrix(particle_repartition);

    if constexpr (AutoGenerated::FlagCompileTime::use_probe)
    {
      // Warning: with some STL implementation,initialiser list constructor with
      // ONE value (vector({value})) leads to vector of zeros with vector.size =
      // value instead of vector[0]=value.
      //  auto chunk = std::vector<unsigned long long>(1);
      //  chunk[0]=AutoGenerated::probe_buffer_size*sizeof(double);

      std::vector<unsigned long long> chunk = {
          AutoGenerated::probe_buffer_size * sizeof(double)};

      MultiMatrixDescription probes = {
          .name = "probes",
          .dims = {0},
          .max_dims = {(n_expected_export + 1) *
                       AutoGenerated::probe_buffer_size},
          .chunk_dims = chunk,
          .compression = true,
          .is_integer = false};

      this->prepare_matrix(probes);
    }
  }

  void PartialExporter::write_number_particle(
      const std::vector<size_t>& distribution)
  {
    append_matrix("records/number_particle", distribution);

    export_counter++;
  }
  void PartialExporter::write_probe(std::span<const double> data)
  {
    append_array("probes", data, probe_counter_n_element);
    probe_counter_n_element += data.size();
  }

  void PartialExporter::write_particle_data(PostProcessing::BonceBuffer&& bonce,
                                            const std::string& ds_name,
                                            bool compress_data)
  {
    PROFILE_SECTION("write_particle_data")
    const auto& [particle_values, spatial_values, ages_values, names] = bonce;

    const size_t n_particles = particle_values.extent(1);
    const size_t n_compartments = bonce.spatial_values.extent(1);

    if (ages_values.has_value())
    {
      auto* ptr_ages = Kokkos::subview(*ages_values, 0, Kokkos::ALL).data();
      this->write_matrix(
          ds_name + "age_hydro/", {ptr_ages, n_particles}, compress_data);
      ptr_ages = Kokkos::subview(*ages_values, 1, Kokkos::ALL).data();
      this->write_matrix(
          ds_name + "age_div/", {ptr_ages, n_particles}, compress_data);
    }

    for (size_t i_name = 0; i_name < bonce.vnames.size(); ++i_name)
    {
      const auto* ptr_particles =
          Kokkos::subview(particle_values, i_name, Kokkos::ALL).data();

      const auto* ptr_spatial =
          Kokkos::subview(spatial_values, i_name, Kokkos::ALL).data();

      this->write_matrix(
          ds_name + names[i_name], {ptr_particles, n_particles}, compress_data);
      this->write_matrix(ds_name + "spatial/" + names[i_name],
                         {ptr_spatial, n_compartments},
                         false);
    }
  }

}; // namespace Core
