
#ifndef NO_MPI
#  include "biocma_cst_config.hpp"
#  include <csignal>
#  include <impl_post_process.hpp>
#  include <mpi_w/iteration_payload.hpp>
#  include <mpi_w/wrap_mpi.hpp>
#  include <simulation/simulation.hpp>
#  include <sync.hpp>
#  include <worker_specific.hpp>

void workers_process([[maybe_unused]] std::shared_ptr<IO::Logger> logger,
                     const ExecInfo& exec,
                     Simulation::SimulationUnit& simulation,
                     const Core::SimulationParameters& params,
                     Core::PartialExporter& partial_exporter)
{
  double d_t = params.d_t;
  size_t n_compartments = simulation.mc_unit->domain.getNumberCompartments();
  MPI_Status status;
  MPI_Request req;
  const bool do_export = true; // TODO

  WrapMPI::IterationPayload payload(n_compartments);

  const auto export_callback = [&](const auto& container)
  {
    PROFILE_SECTION("worker:dump")
    partial_exporter.write_number_particle(
        simulation.mc_unit->getRepartition());

    // if constexpr (AutoGenerated::FlagCompileTime::use_probe)
    // {
    //   PostProcessing::save_probes(simulation, partial_exporter,true);
    // }

    if constexpr (AutoGenerated::FlagCompileTime::dump_particle_state)
    {
      PostProcessing::save_particle_state(simulation, partial_exporter);
    }
  };

  const auto stop_callback = [&](auto& container)
  {
    if (do_export)
    {
      partial_exporter.write_number_particle(
          simulation.mc_unit->getRepartition());
      if constexpr (AutoGenerated::FlagCompileTime::use_probe)
      {
        PostProcessing::save_probes(simulation, partial_exporter);
      }
    }

    last_sync(exec, simulation);

    container.force_remove_dead();

    if (do_export)
    {
      PostProcessing::save_particle_state(simulation, partial_exporter);
    }
    PostProcessing::reset_counter();
  };

  const auto update_callback = [&]()
  {
    payload.recv(0, &status);
    simulation.updateMCHydro(payload.liquid_volumes,
                             payload.liquid_neighbors_flat,
                             payload.proba_leaving_flat,
                             payload.liquid_out_flows);
  };

  const auto cycle_callback =
      [&](double& current_time, auto& container, auto& functors)
  {
    sync_step(exec, simulation);
    sync_prepare_next(simulation, &req);
    simulation.update_feed(current_time, d_t, false);
    WrapMPI::Async::wait(req);
    simulation.cycleProcess(container, d_t, functors);

    current_time += d_t;
  };

  const auto loop_functor = [&](auto&& container)
  {
    auto functors = simulation.init_functors<ComputeSpace>(container);
    // bool stop = false;
    WrapMPI::SIGNALS signal{};

    double current_time = 0;
    while (true)
    {

      signal = WrapMPI::try_recv<WrapMPI::SIGNALS>(0, &status);
      if (signal == WrapMPI::SIGNALS::STOP)
      {
        stop_callback(container);
        break;
      }

      if ((signal == WrapMPI::SIGNALS::DUMP) && do_export)
      {
        export_callback(container);
        continue;
      }

      if (signal == WrapMPI::SIGNALS::HydroUpdate)
      {
        update_callback();
        continue;
      }

      cycle_callback(current_time, container, functors);
    }
  };
  std::visit(loop_functor, simulation.mc_unit->container);
}
#endif // NO_MPI
