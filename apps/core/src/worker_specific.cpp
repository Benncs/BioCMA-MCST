
#ifndef NO_MPI
#  include "biocma_cst_config.hpp"
#  include <csignal>
#  include <impl_post_process.hpp>
#  include <mpi_w/iteration_payload.hpp>
#  include <mpi_w/wrap_mpi.hpp>
#  include <simulation/simulation.hpp>
#  include <sync.hpp>
#  include <transitionner/transitionner.hpp>
#  include <worker_specific.hpp>

void workers_process(const ExecInfo& exec,
                     Simulation::SimulationUnit& simulation,
                     const Core::SimulationParameters& params,
                     std::unique_ptr<CmaUtils::FlowMapTransitionner>&& transitioner,
                     Core::PartialExporter& partial_exporter)
{
  double d_t = params.d_t;
  size_t n_compartments = simulation.mc_unit->domain.getNumberCompartments();
  MPI_Status status;

  WrapMPI::IterationPayload payload(n_compartments * n_compartments, n_compartments);

  const auto loop_functor = [&](auto&& container)
  {
    bool stop = false;
    WrapMPI::SIGNALS signal{};
    double current_time = 0;
    while (!stop)
    {
      signal = WrapMPI::try_recv<WrapMPI::SIGNALS>(0, &status);
      if (signal == WrapMPI::SIGNALS::STOP)
      {
        partial_exporter.write_number_particle(simulation.mc_unit->getRepartition());
        if constexpr (AutoGenerated::FlagCompileTime::use_probe)
        {
          PostProcessing::save_probes(simulation, partial_exporter);
        }

        last_sync(exec, simulation);

        if (simulation.counter() != 0)
        {
          container.clean_dead(simulation.counter());
        }
        PostProcessing::save_particle_state(simulation, partial_exporter);
        PostProcessing::reset_counter();
        stop = true;

        continue;
      }

      if (signal == WrapMPI::SIGNALS::DUMP)
      {
        PROFILE_SECTION("worker:dump")
        partial_exporter.write_number_particle(simulation.mc_unit->getRepartition());

        // if constexpr (AutoGenerated::FlagCompileTime::use_probe)
        // {
        //   PostProcessing::save_probes(simulation, partial_exporter,true);
        // }

        if constexpr (AutoGenerated::FlagCompileTime::dump_particle_state)
        {
          PostProcessing::save_particle_state(simulation, partial_exporter);
        }
        continue;
      }

      payload.recv(0, &status);

      simulation.update(transitioner->advance_worker(
          payload.liquid_flows, payload.liquid_volumes, payload.gas_volumes, payload.neighbors));

      simulation.cycleProcess(container, d_t);

      simulation.update_feed(current_time, d_t);
      current_time += d_t;

      sync_step(exec, simulation);

      sync_prepare_next(simulation);
    }
  };
  std::visit(loop_functor, simulation.mc_unit->container);
}
#endif // NO_MPI
