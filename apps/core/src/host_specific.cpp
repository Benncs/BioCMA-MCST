
#include "common/logger.hpp"
#include <algorithm> //for std::min
#include <biocma_cst_config.hpp>
#include <cma_read/reactorstate.hpp>
#include <common/common.hpp>
#include <common/execinfo.hpp>
#include <core/simulation_parameters.hpp>
#include <cstddef>
#include <dataexporter/main_exporter.hpp>
#include <dataexporter/partial_exporter.hpp>
#include <host_export_handler.hpp>
#include <host_specific.hpp>
#include <impl_post_process.hpp>

#include <mc/unit.hpp>
#include <memory>

#include <progress_bar.hpp>
#include <signal_handling.hpp>
#include <simulation/simulation.hpp>
#include <string>
#include <sync.hpp>
#include <transitionner/transitionner.hpp>
#include <utility>
#include <variant>
#ifndef NO_MPI
#  include <mpi_w/wrap_mpi.hpp>
#endif

#ifndef NO_MPI
#  define BARRIER WrapMPI::barrier();
// In multirank context, fill the struct that will be broadcast to other workers
#  define FILL_PAYLOAD                                                         \
    if constexpr (AutoGenerated::FlagCompileTime::use_mpi)                     \
    {                                                                          \
      const auto& current_reactor_state =                                      \
          transitioner->get_current_reactor_state();                           \
      mpi_payload.fill(current_reactor_state);                                 \
    }                                                                          \
// In multirank context,  Send step payload to other workers
#  define MPI_DISPATCH_MAIN                                                    \
    if constexpr (AutoGenerated::FlagCompileTime::use_mpi)                     \
    {                                                                          \
      mpi_payload.sendAll(exec.n_rank);                                        \
    }

#  define SEND_MPI_SIG_STOP                                                    \
    if constexpr (AutoGenerated::FlagCompileTime::use_mpi)                     \
    {                                                                          \
      WrapMPI::host_dispatch(exec, WrapMPI::SIGNALS::STOP);                    \
    }
#  define INIT_PAYLOAD WrapMPI::HostIterationPayload mpi_payload;
#else
// Without MPI do nothing
#  define BARRIER
#  define FILL_PAYLOAD
#  define MPI_DISPATCH_MAIN
#  define SEND_MPI_SIG_STOP
#  define INIT_PAYLOAD
#endif

#ifdef DEBUG
#  define DEBUG_INSTRUCTION // std::cout << "it: " <<__loop_counter<<std::endl;
#else
#  define DEBUG_INSTRUCTION
#endif

namespace
{
  // constexpr size_t n_particle_trigger_parralel = 1e6;
  void main_loop(const std::shared_ptr<IO::Logger>& logger,
                 const Core::SimulationParameters& params,
                 const ExecInfo& exec,
                 Simulation::SimulationUnit& simulation,
                 std::unique_ptr<CmaUtils::FlowMapTransitionner> transitioner,
                 std::shared_ptr<Core::MainExporter> main_exporter,
                 Core::PartialExporter& partial_exporter);

  std::shared_ptr<Core::MainExporter>
  make_main_exporter(std::shared_ptr<IO::Logger> logger,
                     const ExecInfo& exec,
                     const Core::SimulationParameters& params);

} // namespace

void host_process(
    std::shared_ptr<IO::Logger> logger,
    const ExecInfo& exec,
    Simulation::SimulationUnit& simulation,
    const Core::SimulationParameters& params,
    std::unique_ptr<CmaUtils::FlowMapTransitionner>&& transitioner,
    Core::PartialExporter& partial_exporter)
{

  const auto main_exporter = make_main_exporter(logger, exec, params);

  const auto [n_species, n_compartment] = simulation.getDimensions();

  main_exporter->init_fields(params.number_exported_result,
                             n_compartment,
                             n_species,
                             simulation.two_phase_flow());

  main_exporter->write_initial(simulation.mc_unit->init_weight, params);

  PostProcessing::show_sumup_state(logger, simulation);

  main_loop(logger,
            params,
            exec,
            simulation,
            std::move(transitioner),
            main_exporter,
            partial_exporter);

  PostProcessing::show_sumup_state(logger, simulation);

  SEND_MPI_SIG_STOP;

  PostProcessing::save_particle_state(simulation, partial_exporter);
  last_sync(exec, simulation);
  PostProcessing::final_post_processing(
      logger, exec, params, simulation, main_exporter);

  PostProcessing::reset_counter();
}

namespace
{

  void main_loop(const std::shared_ptr<IO::Logger>& logger,
                 const Core::SimulationParameters& params,
                 const ExecInfo& exec,
                 Simulation::SimulationUnit& simulation,
                 std::unique_ptr<CmaUtils::FlowMapTransitionner> transitioner,
                 std::shared_ptr<Core::MainExporter> main_exporter,
                 Core::PartialExporter& partial_exporter)
  {
    const bool do_export = main_exporter != nullptr;

    // const size_t n_update_feed = 0; //TODO: move elsewhere

    const double d_t = params.d_t;

    const size_t n_iter_simulation = transitioner->get_n_timestep();

    const size_t dump_number =
        std::min(n_iter_simulation,
                 static_cast<size_t>(params.number_exported_result)) -
        1;

    // FIXME when number_exported_result==0 and number_exported_result==1
    const size_t dump_interval =
        (params.number_exported_result != 0 && dump_number != 0)
            ? (n_iter_simulation) / (dump_number) + 1
            : n_iter_simulation + 1;

    double current_time = simulation.get_start_time_mut();
    // size_t update_feed_counter = 0;
    // const size_t update_feed_interval = (n_update_feed==0)? n_iter_simulation
    // : (n_iter_simulation) / (n_update_feed) + 1;

    // use ternary because ExportHandler doesnt provie assigment operator
    ExportHandler exporter_handler(
        do_export ? ExportHandler(
                        main_exporter, exec, dump_interval, n_iter_simulation)
                  : ExportHandler());

    simulation.update_feed(0, 0);
    INIT_PAYLOAD

    if (do_export)
    {
      exporter_handler.pre_post_export(current_time, simulation, transitioner);
    }

    auto loop_functor = [&](auto&& local_container)
    {
      Core::SignalHandler sig;

      auto functors = simulation.init_functors<ComputeSpace>(local_container);

      for (size_t __loop_counter = 0; __loop_counter < n_iter_simulation;
           ++__loop_counter)
      {
        {
          PROFILE_SECTION("host:update_flow::advance")
          simulation.update(transitioner->advance());
        }

        DEBUG_INSTRUCTION

        FILL_PAYLOAD;

        MPI_DISPATCH_MAIN;

        if (do_export)
        {
          // exporter_handler(
          //     current_time, __loop_counter, simulation, partial_exporter);
          if (exporter_handler(
                  current_time, __loop_counter, simulation, partial_exporter))
          {
            // local_container._sort(500);
          }
        }

        sync_step(exec, simulation);
        {
          PROFILE_SECTION("host:sync_update")
          simulation.update_feed(current_time, d_t);
          simulation.step(d_t);
          // From here, contributions can be overwritten
          current_time += d_t;
        }
        sync_prepare_next(simulation);

        simulation.cycleProcess(local_container, d_t, functors);

        if (Core::SignalHandler::is_usr1_raised()) [[unlikely]]
        {
          PostProcessing::save_particle_state(simulation, partial_exporter);
        }

        if (Core::SignalHandler::is_sigint_raised()) [[unlikely]]
        {
          if (logger)
          {
            logger->print("[Host]", "User interruption");
          }
          break;
        }
      } // end for

      local_container.force_remove_dead();
    };

    std::visit(loop_functor, simulation.mc_unit->container);
    if (do_export)
    {
      exporter_handler.pre_post_export(current_time, simulation, transitioner);
      partial_exporter.write_number_particle(
          simulation.mc_unit->getRepartition());
    }

    simulation.get_end_time_mut() = current_time;
    transitioner.reset();
  }

  std::shared_ptr<Core::MainExporter>
  make_main_exporter(std::shared_ptr<IO::Logger> logger,
                     const ExecInfo& exec,
                     const Core::SimulationParameters& params)
  {
    std::shared_ptr<Core::MainExporter> main_exporter =
        std::make_unique<Core::MainExporter>(
            exec, params.results_file_name + std::string(".h5"));

    for (std::size_t i_rank = 0; i_rank < exec.n_rank; ++i_rank)
    {
      std::string group = "files/" + std::to_string(i_rank);

      auto filename = params.results_file_name + "_partial_" +
                      std::to_string(i_rank) + ".h5";

      main_exporter->do_link(filename, group, "/");
    }
    main_exporter->set_logger(std::move(logger));
    return main_exporter;
  }

} // namespace
