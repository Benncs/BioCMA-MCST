#include "dataexporter/data_exporter.hpp"
#include <biocma_cst_config.hpp>
#include <cma_read/reactorstate.hpp>
#include <common/common.hpp>
#include <common/execinfo.hpp>
#include <cstddef>
#include <host_specific.hpp>
#include <iomanip>
#include <mc/unit.hpp>
#include <memory>
#include <optional>
#include <string>

#ifndef NO_MPI
#  include <mpi_w/wrap_mpi.hpp>
#endif
#include <post_process.hpp>
#include <signal_handling.hpp>
#include <simulation/simulation.hpp>
#include <simulation/transitionner.hpp>
#include <sync.hpp>

#include <dataexporter/main_exporter.hpp>
#include <dataexporter/partial_exporter.hpp>

#ifndef NO_MPI
#  define BARRIER MPI_W::barrier();
#else
#  define BARRIER
#endif

// constexpr size_t n_particle_trigger_parralel = 1e6;
static void
main_loop(const Core::SimulationParameters &params,
          const ExecInfo &exec,
          Simulation::SimulationUnit &simulation,
          std::unique_ptr<Simulation::FlowMapTransitioner> transitioner,
          std::unique_ptr<CORE_DE::MainExporter> &main_exporter,
          CORE_DE::PartialExporter &partial_exporter);

static constexpr size_t PROGRESS_BAR_WIDTH = 100;

static void handle_export(const ExecInfo &exec,
                          size_t &dump_counter,
                          size_t dump_interval,
                          size_t n_iter_simulation,
                          size_t __loop_counter,
                          double current_time,
                          Simulation::SimulationUnit &simulation,
                          auto &current_reactor_state,
                          std::unique_ptr<CORE_DE::MainExporter> &main_exporter,
                          CORE_DE::PartialExporter &partial_exporter);

inline static void update_progress_bar(size_t total, size_t current_position)
{

  if constexpr (AutoGenerated::FlagCompileTIme::verbose)
  {
    const int default_precision =
        std::cout.precision(); // NOLINT Conversion long to int
    std::ios::sync_with_stdio(false);
    std::string progressBar(PROGRESS_BAR_WIDTH, ' ');
    size_t progress = (current_position * PROGRESS_BAR_WIDTH) / total;

    for (size_t i = 0; i < progress; ++i)
    {
      progressBar[i] = '*';
    }

    std::cout << "Progress: [" << progressBar << "] " << std::fixed
              << std::setprecision(2)
              << (static_cast<float>(current_position) * 100.0 /
                  static_cast<float>(total))
              << "%\r" << std::flush << std::setprecision(default_precision);
  }
}

#ifdef DEBUG
#  define DEBUG_INSTRUCTION // std::cout << "it: " <<__loop_counter<<std::endl;
#else
#  define DEBUG_INSTRUCTION
#endif

#ifndef NO_MPI
// In multirank context, fill the struct that will be broadcast to other workers
#  define FILL_PAYLOAD                                                     \
    if constexpr (AutoGenerated::FlagCompileTIme::use_mpi)                 \
    {                                                                      \
      mpi_payload.liquid_flows =                                           \
          current_reactor_state->liquid_flow.getViewFlows().data();        \
      mpi_payload.liquid_volumes = current_reactor_state->liquidVolume;    \
      mpi_payload.gas_volumes = current_reactor_state->gasVolume;          \
      mpi_payload.neigbors =                                               \
          current_reactor_state->liquid_flow.getViewNeighors().to_const(); \
    }
#else
#  define FILL_PAYLOAD
#endif // MO_MPI
#ifndef NO_MPI
// In multirank context,  Send step payload to other workers
#  define MPI_DISPATCH_MAIN                                            \
    if constexpr (AutoGenerated::FlagCompileTIme::use_mpi)             \
    {                                                                  \
      for (size_t __macro_j = 1; __macro_j < exec.n_rank; ++__macro_j) \
      {                                                                \
        MPI_W::send(MPI_W::SIGNALS::RUN, __macro_j);                   \
        mpi_payload.send(__macro_j);                                   \
      }                                                                \
    }
#else
#  define MPI_DISPATCH_MAIN
#endif // NO_MPI
#ifndef NO_MPI
// In multirank context,  Send message to worker to ask them to return
#  define SEND_MPI_SIG_STOP                                \
    if constexpr (AutoGenerated::FlagCompileTIme::use_mpi) \
    {                                                      \
      MPI_W::host_dispatch(exec, MPI_W::SIGNALS::STOP);    \
    }
#else
#  define SEND_MPI_SIG_STOP
#endif // NO_MPI

#ifndef NO_MPI
// In multirank context,  Send message to worker to ask them to return
#  define SEND_MPI_SIG_DUMP                                \
    if constexpr (AutoGenerated::FlagCompileTIme::use_mpi) \
    {                                                      \
      MPI_W::host_dispatch(exec, MPI_W::SIGNALS::DUMP);    \
    }
#else
#  define SEND_MPI_SIG_DUMP
#endif // NO_MPI

#ifndef NO_MPI
#  define INIT_PAYLOAD MPI_W::HostIterationPayload mpi_payload;
#else
#  define INIT_PAYLOAD
#endif

std::unique_ptr<CORE_DE::MainExporter>
make_main_exporter(const ExecInfo &exec, const Core::SimulationParameters &params)
{
  std::unique_ptr<CORE_DE::MainExporter> main_exporter =
      std::make_unique<CORE_DE::MainExporter>(exec, params.results_file_name);

  for (std::size_t i_rank = 0; i_rank < exec.n_rank; ++i_rank)
  {
    std::string group = "files/" + std::to_string(i_rank);

    auto filename = params.user_params.results_file_name +
                    "_partial_" + std::to_string(i_rank) + ".h5";

    main_exporter->do_link(filename, group, "/");
  }

  return main_exporter;
}

void host_process(
    const ExecInfo &exec,
    Simulation::SimulationUnit &&simulation,
    const Core::SimulationParameters &params,
    std::unique_ptr<Simulation::FlowMapTransitioner> &&transitioner,
    CORE_DE::PartialExporter &partial_exporter)
{

  std::unique_ptr<CORE_DE::MainExporter> main_exporter =
      make_main_exporter(exec, params);

  const auto [n_species, n_compartment] = simulation.getDim();

  main_exporter->init_fields(params.user_params.number_exported_result,
                             n_compartment,
                             n_species,
                             simulation.two_phase_flow());

  main_exporter->write_initial(simulation.mc_unit->init_weight,
                               params,
                               simulation.mc_unit->domain.getRepartition());

  PostProcessing::show_sumup_state(simulation);

  main_loop(params,
            exec,
            simulation,
            std::move(transitioner),
            main_exporter,
            partial_exporter);

  PostProcessing::show_sumup_state(simulation);

  SEND_MPI_SIG_STOP;

  auto clean_list = [&simulation](auto &&container)
  {
    auto &list = container.get_compute();
    list.remove_dead(simulation.counter());
  };

  std::visit(clean_list, simulation.mc_unit->container);
  PostProcessing::save_final_particle_state(simulation, partial_exporter);
  last_sync(exec, simulation);

  PostProcessing::final_post_processing(
      exec, params, std::move(simulation), main_exporter);
}

void main_loop(const Core::SimulationParameters &params,
               const ExecInfo &exec,
               Simulation::SimulationUnit &simulation,
               std::unique_ptr<Simulation::FlowMapTransitioner> transitioner,
               std::unique_ptr<CORE_DE::MainExporter> &main_exporter,
               CORE_DE::PartialExporter &partial_exporter)
{

  simulation.update_feed(0, 0);

  // const size_t n_update_feed = 0; //TODO: move elsewhere

  const double d_t = params.d_t;

  const size_t n_iter_simulation = transitioner->get_n_timestep();

  const size_t dump_number =
      std::min(n_iter_simulation,
               static_cast<size_t>(params.user_params.number_exported_result)) -
      1;

  const size_t dump_interval = (n_iter_simulation) / (dump_number) + 1;

  size_t dump_counter = 0;
  double current_time = 0.;
  // size_t update_feed_counter = 0;
  // const size_t update_feed_interval = (n_update_feed==0)? n_iter_simulation
  // : (n_iter_simulation) / (n_update_feed) + 1;

  INIT_PAYLOAD

  const auto *current_reactor_state = &transitioner->get_unchecked(0);

  transitioner->update_flow(simulation);

  // FIX CMTOOL
  const auto gas_concentration = simulation.getCgasData();
  auto gas_volume = (!gas_concentration.has_value())
                        ? std::nullopt
                        : std::make_optional(current_reactor_state->gasVolume);

  main_exporter->update_fields(current_time,
                               simulation.getCliqData(),
                               current_reactor_state->liquidVolume,
                               gas_concentration,
                               gas_volume);

  auto loop_functor = [&](auto &&local_container)
  {
    SignalHandler sig;

    auto result = local_container.get_extra();

    auto view_result = result.get_view();

    for (size_t __loop_counter = 0; __loop_counter < n_iter_simulation;
         ++__loop_counter)
    {

      DEBUG_INSTRUCTION

      transitioner->update_flow(simulation);

      current_reactor_state = transitioner->getState();

      FILL_PAYLOAD;

      MPI_DISPATCH_MAIN;

      transitioner->advance(simulation);

      simulation.cycleProcess(local_container, view_result, d_t);

      handle_export(exec,
                    dump_counter,
                    dump_interval,
                    n_iter_simulation,
                    __loop_counter,
                    current_time,
                    simulation,
                    current_reactor_state,
                    main_exporter,
                    partial_exporter);
      sync_step(exec, simulation);

      result.clear(local_container.n_particle());
      result.update_view(view_result);
      simulation.update_feed(current_time, d_t);
      simulation.step(d_t, *current_reactor_state);
      sync_prepare_next(simulation);
      current_time += d_t;

      if (SignalHandler::is_usr1_raised())
      {
        PostProcessing::user_triggered_properties_export(simulation,
                                                         partial_exporter);
      }
    }
  };

  std::visit(loop_functor, simulation.mc_unit->container);

  gas_volume = (!simulation.getCgasData().has_value())
                   ? std::nullopt
                   : std::make_optional(current_reactor_state->gasVolume);

  main_exporter->update_fields(current_time,
                               simulation.getCliqData(),
                               current_reactor_state->liquidVolume,
                               simulation.getCgasData(),
                               gas_volume);
  partial_exporter.write_number_particle(
      simulation.mc_unit->domain.getRepartition());

  if constexpr (AutoGenerated::FlagCompileTIme::use_probe)
  {
    // PostProcessing::save_probes(simulation, partial_exporter);
    auto &probes = simulation.probes;

    const double *const probe_ptr = probes.raw_get();
    partial_exporter.write_probe({probe_ptr, Simulation::Probes::buffer_size});
    probes.clear();
  }

  transitioner.reset();
}

// NOLINTBEGIN
void handle_export(const ExecInfo &exec, /*/Exec is used for MPI **/
                   size_t &dump_counter,
                   const size_t dump_interval,
                   const size_t n_iter_simulation,
                   const size_t __loop_counter,
                   const double current_time,
                   Simulation::SimulationUnit &simulation,
                   auto &current_reactor_state,
                   std::unique_ptr<CORE_DE::MainExporter> &main_exporter,
                   CORE_DE::PartialExporter &partial_exporter)
// NOLINTEND
{
  if (++dump_counter == dump_interval)
  {
    SEND_MPI_SIG_DUMP
    auto vg = (simulation.getCgasData().has_value())
                  ? std::make_optional(current_reactor_state->gasVolume)
                  : std::nullopt;

    update_progress_bar(n_iter_simulation, __loop_counter);
    main_exporter->update_fields(current_time,
                                 simulation.getCliqData(),
                                 current_reactor_state->liquidVolume,
                                 simulation.getCgasData(),
                                 vg);

    partial_exporter.write_number_particle(
        simulation.mc_unit->domain.getRepartition());

    if constexpr (AutoGenerated::FlagCompileTIme::use_probe)
    {
      PostProcessing::save_probes(simulation, partial_exporter);
    }
    if constexpr (AutoGenerated::FlagCompileTIme::dump_particle_state)
    {
      PostProcessing::user_triggered_properties_export(simulation,
                                                       partial_exporter);
    }

    dump_counter = 0;
  }
}
