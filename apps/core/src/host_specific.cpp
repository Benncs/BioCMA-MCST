
#include "common/logger.hpp"
#include <algorithm> //for std::min
#include <biocma_cst_config.hpp>
#include <cma_read/reactorstate.hpp>
#include <common/common.hpp>
#include <common/execinfo.hpp>
#include <core/simulation_parameters.hpp>
#include <cstddef>
#include <dataexporter/main_exporter.hpp>
#include <dataexporter/partial_exporter.hpp>
#include <host_specific.hpp>
#include <impl_post_process.hpp>
#include <iomanip>
#include <ios>
#include <iostream>
#include <mc/unit.hpp>
#include <memory>
#include <optional>
#include <ostream>
#include <signal_handling.hpp>
#include <simulation/simulation.hpp>
#include <string>
#include <sync.hpp>
#include <transitionner/transitionner.hpp>
#include <utility>
#include <variant>

#ifndef NO_MPI
#  include <mpi_w/wrap_mpi.hpp>
#endif

#ifndef NO_MPI
#  define BARRIER WrapMPI::barrier();
// In multirank context, fill the struct that will be broadcast to other workers
#  define FILL_PAYLOAD                                                         \
    if constexpr (AutoGenerated::FlagCompileTime::use_mpi)                     \
    {                                                                          \
      const auto& current_reactor_state =                                      \
          transitioner->get_current_reactor_state();                           \
      mpi_payload.fill(current_reactor_state);                                 \
    }                                                                          \
// In multirank context,  Send step payload to other workers
#  define MPI_DISPATCH_MAIN                                                    \
    if constexpr (AutoGenerated::FlagCompileTime::use_mpi)                     \
    {                                                                          \
      mpi_payload.sendAll(exec.n_rank);                                        \
    }

#  define SEND_MPI_SIG_STOP                                                    \
    if constexpr (AutoGenerated::FlagCompileTime::use_mpi)                     \
    {                                                                          \
      WrapMPI::host_dispatch(exec, WrapMPI::SIGNALS::STOP);                    \
    }
#  define SEND_MPI_SIG_DUMP                                                    \
    if constexpr (AutoGenerated::FlagCompileTime::use_mpi)                     \
    {                                                                          \
      WrapMPI::host_dispatch(exec, WrapMPI::SIGNALS::DUMP);                    \
    }
#  define INIT_PAYLOAD WrapMPI::HostIterationPayload mpi_payload;
#else
// Without MPI do nothing
#  define BARRIER
#  define FILL_PAYLOAD
#  define MPI_DISPATCH_MAIN
#  define SEND_MPI_SIG_STOP
#  define SEND_MPI_SIG_DUMP
#  define INIT_PAYLOAD
#endif

#ifdef DEBUG
#  define DEBUG_INSTRUCTION // std::cout << "it: " <<__loop_counter<<std::endl;
#else
#  define DEBUG_INSTRUCTION
#endif

namespace IO
{
  constexpr size_t PROGRESS_BAR_WIDTH = 100; // Number of
  constexpr char PROGRESS_BAR_SYMBOL = '*';

  class ProgressBar
  {
  public:
    ProgressBar()
    {
      buffer = std::string(PROGRESS_BAR_WIDTH, ' ');
    }

    void show(std::ostream& out_stream, size_t total, size_t current_position)
    {

      std::ios::sync_with_stdio(false);
      size_t progress = (current_position * PROGRESS_BAR_WIDTH) / total;

      std::fill_n(buffer.begin(), progress, PROGRESS_BAR_SYMBOL);
      out_stream << "Progress: [" << buffer << "] " << std::fixed
                 << std::setprecision(2)
                 << (static_cast<float>(current_position) * 100.0 /
                     static_cast<float>(total))
                 << "%\r" << std::flush << std::setprecision(default_precision);
    }

    void show_percentage(std::ostream& out_stream,
                         size_t total,
                         size_t current_position) const
    {
      std::ios::sync_with_stdio(false);
      out_stream << "Progress: [" << std::fixed << std::setprecision(2)
                 << (static_cast<float>(current_position) * 100.0 /
                     static_cast<float>(total))
                 << "%" << "]\r" << std::flush
                 << std::setprecision(default_precision);
    }

  private:
    std::string buffer;

    const int default_precision =
        std::cout.precision(); // NOLINT Conversion long to int
  };

  static ProgressBar progressbar = ProgressBar();
} // namespace IO

namespace
{

  // constexpr size_t n_particle_trigger_parralel = 1e6;
  void main_loop(const std::shared_ptr<IO::Logger>& logger,
                 const Core::SimulationParameters& params,
                 const ExecInfo& exec,
                 Simulation::SimulationUnit& simulation,
                 std::unique_ptr<CmaUtils::FlowMapTransitionner> transitioner,
                 std::unique_ptr<Core::MainExporter>& main_exporter,
                 Core::PartialExporter& partial_exporter);

  void handle_export(const ExecInfo& exec,
                     size_t& dump_counter,
                     size_t dump_interval,
                     size_t n_iter_simulation,
                     size_t __loop_counter,
                     double current_time,
                     Simulation::SimulationUnit& simulation,
                     std::unique_ptr<Core::MainExporter>& main_exporter,
                     Core::PartialExporter& partial_exporter);

  std::unique_ptr<Core::MainExporter>
  make_main_exporter(const ExecInfo& exec,
                     const Core::SimulationParameters& params)
  {
    std::unique_ptr<Core::MainExporter> main_exporter =
        std::make_unique<Core::MainExporter>(
            exec, params.results_file_name + std::string(".h5"));

    for (std::size_t i_rank = 0; i_rank < exec.n_rank; ++i_rank)
    {
      std::string group = "files/" + std::to_string(i_rank);

      auto filename = params.results_file_name + "_partial_" +
                      std::to_string(i_rank) + ".h5";

      main_exporter->do_link(filename, group, "/");
    }

    return main_exporter;
  }

} // namespace

void host_process(
    std::shared_ptr<IO::Logger> logger,
    const ExecInfo& exec,
    Simulation::SimulationUnit& simulation,
    const Core::SimulationParameters& params,
    std::unique_ptr<CmaUtils::FlowMapTransitionner>&& transitioner,
    Core::PartialExporter& partial_exporter)
{

  std::unique_ptr<Core::MainExporter> main_exporter =
      make_main_exporter(exec, params);

  main_exporter->set_logger(logger);

  const auto [n_species, n_compartment] = simulation.getDimensions();

  main_exporter->init_fields(params.number_exported_result,
                             n_compartment,
                             n_species,
                             simulation.two_phase_flow());

  main_exporter->write_initial(simulation.mc_unit->init_weight, params);

  PostProcessing::show_sumup_state(logger, simulation);

  main_loop(logger,
            params,
            exec,
            simulation,
            std::move(transitioner),
            main_exporter,
            partial_exporter);

  PostProcessing::show_sumup_state(logger, simulation);

  SEND_MPI_SIG_STOP;

  // auto clean_list = [&simulation](auto& container)
  // {
  //   if (simulation.counter() != 0)
  //   {
  //     container.clean_dead(simulation.counter());
  //   }
  // };

  // std::visit(clean_list, simulation.mc_unit->container);
  PostProcessing::save_particle_state(simulation, partial_exporter);
  last_sync(exec, simulation);
  PostProcessing::final_post_processing(
      logger, exec, params, simulation, main_exporter);

  PostProcessing::reset_counter();
}

namespace
{

  void main_loop(const std::shared_ptr<IO::Logger>& logger,
                 const Core::SimulationParameters& params,
                 const ExecInfo& exec,
                 Simulation::SimulationUnit& simulation,
                 std::unique_ptr<CmaUtils::FlowMapTransitionner> transitioner,
                 std::unique_ptr<Core::MainExporter>& main_exporter,
                 Core::PartialExporter& partial_exporter)
  {

    simulation.update_feed(0, 0);

    // const size_t n_update_feed = 0; //TODO: move elsewhere

    const double d_t = params.d_t;

    const size_t n_iter_simulation = transitioner->get_n_timestep();

    const size_t dump_number =
        std::min(n_iter_simulation,
                 static_cast<size_t>(params.number_exported_result)) -
        1;

    // FIXME when number_exported_result==0 and number_exported_result==1
    const size_t dump_interval =
        (params.number_exported_result != 0 && dump_number != 0)
            ? (n_iter_simulation) / (dump_number) + 1
            : n_iter_simulation + 1;

    size_t dump_counter = 0;
    double current_time = simulation.get_start_time_mut();
    // size_t update_feed_counter = 0;
    // const size_t update_feed_interval = (n_update_feed==0)? n_iter_simulation
    // : (n_iter_simulation) / (n_update_feed) + 1;
    const bool do_export = main_exporter != nullptr;
    INIT_PAYLOAD

    {
      const auto& current_reactor_state =
          transitioner->get_current_reactor_state();

      if (do_export)
      {

        // FIX CMTOOL
        const auto gas_concentration = simulation.getCgasData();
        auto gas_volume =
            (!gas_concentration.has_value())
                ? std::nullopt
                : std::make_optional(current_reactor_state.gasVolume);
        std::optional<std::span<std::size_t>> event_span = std::nullopt;
        if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
        {
          event_span = simulation.mc_unit->events.get_span();
        }
        main_exporter->update_fields(current_time,
                                     simulation.getCliqData(),
                                     current_reactor_state.liquidVolume,
                                     gas_concentration,
                                     gas_volume,
                                     simulation.getMTRData(),
                                     event_span);

        if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
        {
          simulation.mc_unit->events.clear();
        }
      }
    }

    auto loop_functor = [&](auto&& local_container)
    {
      Core::SignalHandler sig;

      auto functors = simulation.init_functors<ComputeSpace>(local_container);

      for (size_t __loop_counter = 0; __loop_counter < n_iter_simulation;
           ++__loop_counter)
      {

        DEBUG_INSTRUCTION

        FILL_PAYLOAD;

        MPI_DISPATCH_MAIN;

        {
          PROFILE_SECTION("host:update_flow::advance")
          simulation.update(transitioner->advance());
        }

        if (do_export)
        {
          handle_export(exec,
                        dump_counter,
                        dump_interval,
                        n_iter_simulation,
                        __loop_counter,
                        current_time,
                        simulation,
                        main_exporter,
                        partial_exporter);
        }

        sync_step(exec, simulation);
        {
          PROFILE_SECTION("host:sync_update")
          simulation.update_feed(current_time, d_t);
          simulation.step(d_t);
          current_time += d_t;
        }
        sync_prepare_next(simulation);

        simulation.cycleProcess(local_container, d_t, functors);

        if (Core::SignalHandler::is_usr1_raised())
        {
          PostProcessing::save_particle_state(simulation, partial_exporter);
        }

        if (Core::SignalHandler::is_sigint_raised())
        {
          if (logger)
          {
            logger->print("[Host]", "User interruption");
          }
          break;
        }
      }

      local_container.clean_dead(simulation.dead_counter());
    };

    std::visit(loop_functor, simulation.mc_unit->container);

    if (do_export)
    {

      const auto& last_current_reactor_state =
          transitioner->get_current_reactor_state();
      auto gas_volume =
          (!simulation.getCgasData().has_value())
              ? std::nullopt
              : std::make_optional(last_current_reactor_state.gasVolume);

      std::optional<std::span<std::size_t>> event_span = std::nullopt;

      if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
      {
        event_span = simulation.mc_unit->events.get_span();
      }

      main_exporter->update_fields(current_time,
                                   simulation.getCliqData(),
                                   last_current_reactor_state.liquidVolume,
                                   simulation.getCgasData(),
                                   gas_volume,
                                   simulation.getMTRData(),
                                   event_span);

      if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
      {
        simulation.mc_unit->events.clear();
      }

      partial_exporter.write_number_particle(
          simulation.mc_unit->getRepartition());
    }

    // if constexpr (AutoGenerated::FlagCompileTime::use_probe)
    // {
    //   PostProcessing::save_probes(simulation, partial_exporter,true);
    // }
    simulation.get_end_time_mut() = current_time;
    transitioner.reset();
  }

  // NOLINTBEGIN
  void handle_export(const ExecInfo& exec, /*/Exec is used for MPI **/
                     size_t& dump_counter,
                     const size_t dump_interval,
                     const size_t n_iter_simulation,
                     const size_t __loop_counter,
                     const double current_time,
                     Simulation::SimulationUnit& simulation,
                     std::unique_ptr<Core::MainExporter>& main_exporter,
                     Core::PartialExporter& partial_exporter)
  // NOLINTEND
  {

    PROFILE_SECTION("host:handle_export")
    if (++dump_counter == dump_interval)
    {

      std::optional<std::span<std::size_t>> event_span = std::nullopt;

      if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
      {
        event_span = simulation.mc_unit->events.get_span();
      }
      const auto& state = simulation.getState();
      SEND_MPI_SIG_DUMP
      auto vg = (simulation.getCgasData().has_value())
                    ? std::make_optional(state.gas->volume)
                    : std::nullopt;
      if constexpr (AutoGenerated::FlagCompileTime::verbose)
      {
        // IO::progressbar.show_percentage(std::cout,n_iter_simulation,
        // __loop_counter);
        IO::progressbar.show(std::cout, n_iter_simulation, __loop_counter);
      }

      main_exporter->update_fields(current_time,
                                   simulation.getCliqData(),
                                   state.liq->volume,
                                   simulation.getCgasData(),
                                   vg,
                                   simulation.getMTRData(),
                                   event_span);
      if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
      {
        simulation.mc_unit->events.clear();
      }

      partial_exporter.write_number_particle(
          simulation.mc_unit->getRepartition());

      if constexpr (AutoGenerated::FlagCompileTime::use_probe)
      {
        PostProcessing::save_probes(simulation, partial_exporter);
      }
      if constexpr (AutoGenerated::FlagCompileTime::dump_particle_state)
      {
        PostProcessing::save_particle_state(simulation, partial_exporter);
      }

      dump_counter = 0;
    }
  }

} // namespace
