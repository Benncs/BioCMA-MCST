#include <host_export_handler.hpp>
#include <impl_post_process.hpp>
#include <iostream>

#ifndef NO_MPI
#  include <mpi_w/wrap_mpi.hpp>
#endif

#ifndef NO_MPI
#  define SEND_MPI_SIG_DUMP                                                    \
    if constexpr (AutoGenerated::FlagCompileTime::use_mpi)                     \
    {                                                                          \
      WrapMPI::host_dispatch(exec, WrapMPI::SIGNALS::DUMP);                    \
    }
#else
#  define SEND_MPI_SIG_DUMP
#endif

void ExportHandler::pre_post_export(
    const double current_time,
    const Simulation::SimulationUnit& simulation,
    const std::unique_ptr<CmaUtils::FlowMapTransitionner>& transitioner)
{
  // Retrieve the current reactor state from the transitioner
  const auto& current_reactor_state = transitioner->get_current_reactor_state();

  // Get gas concentration from the simulation; if available, also get the gas
  // volume
  const auto gas_concentration = simulation.getCgasData();
  auto gas_volume = (!gas_concentration.has_value())
                        ? std::nullopt
                        : std::make_optional(current_reactor_state.gasVolume);

  // Prepare event span if event counter is enabled at compile time
  std::optional<std::span<std::size_t>> event_span = std::nullopt;
  if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
  {
    event_span = simulation.mc_unit->events.get_span();
  }

  // Update the main exporter with the current simulation data
  main_exporter->update_fields(current_time,
                               simulation.getCliqData(),
                               current_reactor_state.liquidVolume,
                               gas_concentration,
                               gas_volume,
                               simulation.getMTRData(),
                               event_span);

  // Clear the event counter if event counter is enabled at compile time
  if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
  {
    simulation.mc_unit->events.clear();
  }
}

ExportHandler::ExportHandler(std::shared_ptr<Core::MainExporter> _main_exporter,
                             ExecInfo _exec,
                             size_t _dump_interval,
                             size_t _n_iter_simulation)
    : dump_interval(_dump_interval), n_iter_simulation(_n_iter_simulation),
      exec(_exec), main_exporter(std::move(_main_exporter))
{
}

// void ExportHandler::operator()(double current_time,
//                                size_t __loop_counter,
//                                Simulation::SimulationUnit& simulation,
//                                Core::PartialExporter& partial_exporter)
// {
//   PROFILE_SECTION("host:handle_export")
//   if (++dump_counter == dump_interval)
//   {

//     std::optional<std::span<std::size_t>> event_span = std::nullopt;

//     if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
//     {
//       event_span = simulation.mc_unit->events.get_span();
//     }
//     const auto& state = simulation.getState();
//     SEND_MPI_SIG_DUMP
//     auto vg = (simulation.getCgasData().has_value())
//                   ? std::make_optional(state.gas->volume)
//                   : std::nullopt;
//     if constexpr (AutoGenerated::FlagCompileTime::verbose)
//     {
//       progressbar.show(std::cout, n_iter_simulation, __loop_counter);
//     }

//     main_exporter->update_fields(current_time,
//                                  simulation.getCliqData(),
//                                  state.liq->volume,
//                                  simulation.getCgasData(),
//                                  vg,
//                                  simulation.getMTRData(),
//                                  event_span);
//     if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
//     {
//       simulation.mc_unit->events.clear();
//     }

//     partial_exporter.write_number_particle(
//         simulation.mc_unit->getRepartition());

//     if constexpr (AutoGenerated::FlagCompileTime::use_probe)
//     {
//       PostProcessing::save_probes(simulation, partial_exporter);
//     }
//     if constexpr (AutoGenerated::FlagCompileTime::dump_particle_state)
//     {
//       PostProcessing::save_particle_state(simulation, partial_exporter);
//     }

//     dump_counter = 0;
//   }
// }
//
//
void ExportHandler::operator()(double current_time,
                               size_t loop_counter,
                               Simulation::SimulationUnit& simulation,
                               Core::PartialExporter& partial_exporter)
{
  PROFILE_SECTION("host:handle_export")

  // Only proceed if the dump interval is reached
  if (++dump_counter != dump_interval)
  {
    return;
  }

  // Prepare event span if event counter is enabled
  const auto event_span = prepareEventSpan(simulation);

  // Retrieve the current simulation state
  const auto& state = simulation.getState();

  // Send MPI dump signal
  SEND_MPI_SIG_DUMP

  // Prepare optional gas volume
  const auto vg = (simulation.getCgasData().has_value())
                      ? std::make_optional(state.gas->volume)
                      : std::nullopt;

  // Update progress bar if verbose mode is enabled
  if constexpr (AutoGenerated::FlagCompileTime::verbose)
  {
    progressbar.show(std::cout, n_iter_simulation, loop_counter);
  }

  // Update main exporter with current simulation data
  main_exporter->update_fields(current_time,
                               simulation.getCliqData(),
                               state.liq->volume,
                               simulation.getCgasData(),
                               vg,
                               simulation.getMTRData(),
                               event_span);

  // Clear event counter if enabled
  if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
  {
    simulation.mc_unit->events.clear();
  }

  // Write particle repartition
  partial_exporter.write_number_particle(simulation.mc_unit->getRepartition());

  // Save probes and particle state if enabled
  if constexpr (AutoGenerated::FlagCompileTime::use_probe)
  {
    PostProcessing::save_probes(simulation, partial_exporter);
  }
  if constexpr (AutoGenerated::FlagCompileTime::dump_particle_state)
  {
    PostProcessing::save_particle_state(simulation, partial_exporter);
  }

  // Reset dump counter
  dump_counter = 0;
}

std::optional<std::span<std::size_t>>
ExportHandler::prepareEventSpan(Simulation::SimulationUnit& simulation)
{
  if constexpr (AutoGenerated::FlagCompileTime::enable_event_counter)
  {
    return simulation.mc_unit->events.get_span();
  }
  return std::nullopt;
}
