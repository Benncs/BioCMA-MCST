
#include <api/api.hpp>
#include <cli_parser.hpp>
#include <common/console.hpp>
#include <common/execinfo.hpp>
#include <core/case_data.hpp>
#include <core/simulation_parameters.hpp>
#include <filesystem>
#include <ios>
#include <iostream>
#include <memory>
#include <optional>
#include <rt_init.hpp>
#include <simulation/feed_descriptor.hpp>
#include <sstream>
#include <string>
#include <string_view>
#include <utility>
#include <wrap_init_model_selector.hpp>

#ifdef DECLARE_EXPORT_UDF
#  include <udf_includes.hpp>
std::shared_ptr<DynamicLibrary> wrap_non_scoped_udf(std::string_view path,
                                                    bool load)
{
  if (load)
  {
    return UnsafeUDF::Loader::init_lib(path);
  }

  return nullptr;
}
#  define DECLARE_LOADER(__path__, __load_flag__)                              \
    auto _ = wrap_non_scoped_udf(__path__, __load_flag__);
#else

#  define DECLARE_LOADER(__path__, __junk__)                                   \
    (void)__path__;                                                            \
    (void)__junk__
#endif

#ifndef NO_MPI
#  include <mpi_w/wrap_mpi.hpp>
#endif

#ifdef USE_PYTHON_MODULE
#  include <pymodule/import_py.hpp>
#  define INTERPRETER_INIT auto _interpreter_handle = init_python_interpreter();
#else
#  define INTERPRETER_INIT
#endif

#ifndef NO_MPI
#  define HANDLE_RC(__api_results__)                                           \
    {                                                                          \
      auto rc = (__api_results__);                                             \
      if (!rc)                                                                 \
      {                                                                        \
        logger->error(IO::format(#__api_results__, " ", rc.get()));            \
        WrapMPI::critical_error();                                             \
        return -1;                                                             \
      }                                                                        \
    }
#else
#  define HANDLE_RC(__api_results__)                                           \
    {                                                                          \
      auto rc = (__api_results__);                                             \
      if (!rc)                                                                 \
      {                                                                        \
        logger->error(IO::format(#__api_results__, " ", rc.get()));            \
        return -1;                                                             \
      }                                                                        \
    }
#endif

/**
 * @brief Check if result path exist or not and ask for overriding if yes
 * @return true if override results_path
 */
static bool override_result_path(const std::shared_ptr<IO::Logger>& logger,
                                 const Core::UserControlParameters& params,
                                 const ExecInfo& exec);
static int parse_callback_ok(
    std::shared_ptr<IO::Logger>&& logger,
    Core::UserControlParameters&& user_params,
    std::optional<std::unique_ptr<Api::SimulationInstance>>& handle);
static std::string log_start_up();
int main(int argc, char** argv)
{
  auto logger = std::make_shared<IO::Console>();
  logger->toggle_print();
  logger->toggle_alert();
  logger->toggle_error();

  int rc = -1;
  {
    logger->raw_log(log_start_up());

    auto handle = Api::SimulationInstance::init(argc, argv);

    if (!handle)
    {
      logger->error("Error Handle init");
      return -1;
    }

    rc = parse_cli(logger, argc, argv)
             .match(
                 [&](auto&& user_params)
                 {
                   return parse_callback_ok(
                       logger,
                       std::forward<decltype(user_params)>(user_params),
                       handle);
                 },
                 [&logger](auto&& val)
                 {
                   logger->error(val);
                   logger->raw_log(get_help_message());
                   return 1;
                 });
  }

  return rc;
}

int parse_callback_ok(
    std::shared_ptr<IO::Logger>&& logger,
    Core::UserControlParameters&& user_params,
    std::optional<std::unique_ptr<Api::SimulationInstance>>& handle)
{
#ifdef USE_UDF
  const char* env_p = std::getenv("LIB_BIOMC_UDF");

  const bool f_load_udf = AutoGenerated::request_udf(user_params.model_name);
  if (f_load_udf)
  {
    if (env_p == nullptr)
    {
      logger->error("var LIB_BIOMC_UDF not found");
      return -1;
    }
  }
  DECLARE_LOADER(env_p, f_load_udf);
#endif
  auto& h = *handle;

  if (!override_result_path(logger, user_params, h->get_exec_info()))
  {
    return -1;
  }
  h->set_logger(std::cref(logger));
  h->set_feed_constant(7.701635339554948e-06, 2, 0, 0);
  const auto load_serde = user_params.load_serde;
  INTERPRETER_INIT
  {
    HANDLE_RC(h->register_parameters(
        std::forward<decltype(user_params)>(user_params)));
    HANDLE_RC(h->apply(load_serde));
    HANDLE_RC(h->exec());
  }
  return 0;
}

bool override_result_path(const std::shared_ptr<IO::Logger>& logger,
                          const Core::UserControlParameters& params,
                          const ExecInfo& exec)
{
  bool flag = true;
  if (exec.current_rank == 0)
  {
    if (std::filesystem::exists(params.results_file_name +
                                std::string(".h5")) &&
        !params.force_override)
    {
      std::ios_base::sync_with_stdio(true); // FIXME
      logger->print("", "Override results ? (y/n)");
      std::string res;
      std::cin >> res;
      flag = res == "y";
      std::ios_base::sync_with_stdio(false);
    }
  }
#ifndef NO_MPI
  WrapMPI::barrier();
  WrapMPI::broadcast(flag, 0);
#endif
  return flag;
}

static std::string log_start_up()
{
  std::stringstream os;
  os << "--------" << std::endl;
  os << "Bio-CMA-MC Simulation tool\r\n";
  os << "\tV" << _BIOMC_VERSION_MAJOR << "." << _BIOMC_VERSION_MINOR << "."
     << _BIOMC_VERSION_DEV << "\r\n";
  os << "\tMode " << _BIOMC_BUILD_MODE << "\r\n";
  os << "--------" << std::endl;
  return os.str();
}
