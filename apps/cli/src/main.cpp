
#include <api/api.hpp>
#include <cli_parser.hpp>
#include <common/execinfo.hpp>
#include <core/case_data.hpp>
#include <core/simulation_parameters.hpp>
#include <filesystem>
#include <iostream>
#include <memory>
#include <optional>
#include <rt_init.hpp>
#include <simulation/feed_descriptor.hpp>
#include <stream_io.hpp>
#include <string>
#include <string_view>
#include <utility>
#include <wrap_init_model_selector.hpp>

#ifdef DECLARE_EXPORT_UDF
#  include <udf_includes.hpp>
std::shared_ptr<DynamicLibrary> wrap_non_scoped_udf(std::string_view path, bool load)
{
  if (load)
  {
    return UnsafeUDF::Loader::init_lib(path);
  }
  else
  {
    return nullptr;
  }
}
#  define DECLARE_LOADER(__path__, __load_flag__)                                                  \
    auto _ = wrap_non_scoped_udf(__path__, __load_flag__);
#else

#  define DECLARE_LOADER(__path__, __junk__)                                                       \
    (void)__path__;                                                                                \
    (void)__junk__
#endif

#ifndef NO_MPI
#  include <mpi_w/wrap_mpi.hpp>
#endif

#ifdef USE_PYTHON_MODULE
#  include <pymodule/import_py.hpp>
#  define INTERPRETER_INIT auto _interpreter_handle = init_python_interpreter();
#else
#  define INTERPRETER_INIT
#endif

#ifndef NO_MPI
#  define HANDLE_RC(__api_results__)                                                               \
    {                                                                                              \
      auto rc = (__api_results__);                                                                 \
      if (!rc)                                                                                     \
      {                                                                                            \
        std::cout << "ERROR " << #__api_results__ << " " << rc.get() << std::endl;                 \
        WrapMPI::critical_error();                                                                 \
        return -1;                                                                                 \
      }                                                                                            \
    }
#else
#  define HANDLE_RC(__api_results__)                                                               \
    {                                                                                              \
      auto rc = (__api_results__);                                                                 \
      if (!rc)                                                                                     \
      {                                                                                            \
        std::cout << "ERROR " << #__api_results__ << " " << rc.get() << std::endl;                 \
        return -1;                                                                                 \
      }                                                                                            \
    }
#endif

/**
 * @brief Check if result path exist or not and ask for overriding if yes
 * @return true if override results_path
 */
static bool override_result_path(const Core::UserControlParameters& params, const ExecInfo& exec);
static int parse_callback_ok(Core::UserControlParameters&& user_params,
                             std::optional<std::unique_ptr<Api::SimulationInstance>>& handle);
static void log_start_up();
int main(int argc, char** argv)
{

  log_start_up();

  auto handle = Api::SimulationInstance::init(argc, argv);

  if (!handle)
  {
    std::cerr << "Error Handle init" << std::endl;
    return -1;
  }

  return parse_cli(argc, argv)
      .match(
          [&](auto&& user_params)
          { return parse_callback_ok(std::forward<decltype(user_params)>(user_params), handle); },
          [](auto&& val)
          {
            std::cout << "Err: " << val << std::endl;
            showHelp(std::cout);
            return 1;
          });
}

int parse_callback_ok(Core::UserControlParameters&& user_params,
                      std::optional<std::unique_ptr<Api::SimulationInstance>>& handle)
{
  DECLARE_LOADER("/home-local/casale/Documents/code/poc/builddir/host/apps/udf_model/"
                 "libudf_model.so",
                 AutoGenerated::request_udf(user_params.model_name));

  auto& h = *handle;
  if (!override_result_path(user_params, h->get_exec_info()))
  {
    return -1;
  }

  const auto load_serde = user_params.load_serde;
  INTERPRETER_INIT
  REDIRECT_SCOPE({
    HANDLE_RC(h->register_parameters(std::forward<decltype(user_params)>(user_params)));

    // const auto fd = Simulation::Feed::FeedFactory::constant(
    //     2.33333333333333E-05, 300e-3, 1, 1,10, true);

    // const auto fd_liq = Simulation::Feed::FeedFactory::constant(
    //     10e-3*0.1/3600, 5, 0, 0,0, false);

    // h->set_feed(fd, Phase::Gas);
    // h->set_feed(fd_liq, Phase::Liquid);

    HANDLE_RC(h->apply(load_serde));
    HANDLE_RC(h->exec());
  })
  return 0;
}

bool override_result_path(const Core::UserControlParameters& params, const ExecInfo& exec)
{
  bool flag = true;
  if (exec.current_rank == 0)
  {
    if (std::filesystem::exists(params.results_file_name + std::string(".h5")) &&
        !params.force_override)
    {
      std::cout << "Override results ? (y/n)" << std::endl;
      std::string res;
      std::cin >> res;
      flag = res == "y";
    }
  }
#ifndef NO_MPI
  WrapMPI::barrier();
  WrapMPI::broadcast(flag, 0);
#endif
  return flag;
}

static void log_start_up()
{
  std::cout << "--------" << std::endl;
  std::cout << "Bio-CMA-MC Simulation tool\r\n";
  std::cout << "\tV" << _BIOMC_VERSION_MAJOR << "." << _BIOMC_VERSION_MINOR << "."
            << _BIOMC_VERSION_DEV << "\r\n";
  std::cout << "\tMode " << _BIOMC_BUILD_MODE << "\r\n";
  std::cout << "--------" << std::endl;
}