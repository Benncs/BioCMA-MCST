#ifndef __MC_INIT_HPP__
#define __MC_INIT_HPP__

#include <cassert>
#include <common/execinfo.hpp>
#include <common/kokkos_vector.hpp>
#include <cstdint>
#include <mc/particles/extra_process.hpp>
#include <mc/particles/mcparticles.hpp>
#include <mc/particles/particles_container.hpp>
#include <mc/prng/prng.hpp>
#include <mc/unit.hpp>
#include <memory>
#include <utility>

namespace
{
  template <typename ListType> struct PostInitFunctor
  {

    PostInitFunctor(ListType _list, double _new_weigth)
        : list(std::move(_list)), new_weigth(_new_weigth)
    {
    }

    KOKKOS_INLINE_FUNCTION void operator()(std::size_t i_particle) const
    {
      list._owned_data(i_particle).properties.weight = new_weigth;
    }
    ListType list;
    double new_weigth;
  };
} // namespace

namespace MC
{

  constexpr bool uniform_init = true;

  namespace
  {

    /**
     * @brief helper function to get initial particle weight
     */
    inline double get_initial_weight(double scale_factor,
                                     double particle_concentration,
                                     double total_volume,
                                     double mass_cell,
                                     size_t n_particles)
    {
      // Scale factor is a fine tunning adjustement in case of misprediction of
      // particle weight particle_concentration is expected to be the real cell
      // concentration in g/L (kg/m3) Total volume is expected to be in m3 As a
      // result we can calculate the mass carried by each MC particle
      return scale_factor * particle_concentration * total_volume /
             static_cast<double>(n_particles) / mass_cell;
    }

    /**
     */
    template <ParticleModel Model>
    void impl_init(std::unique_ptr<MonteCarloUnit>& unit,
                   size_t particle_per_process,
                   double& total_mass)
    {

      auto container = ParticlesContainer<Model>(particle_per_process);

      auto& compartments = unit->domain.data();
      auto& list = container.get_compute();

      auto rng = unit->rng;
      auto particle_rng = list.rng_instance;

      list.set_allocation_factor(AutoGenerated::default_particle_container_allocation_factor);
      container.get_extra() = Results<ComputeSpace, Model>(particle_per_process);

      container.get_extra().extra_process.set_allocation_factor(
          AutoGenerated::default_particle_container_allocation_factor);
      const auto n_compartments = unit->domain.getNumberCompartments();

      uint64_t min_c = 0;
      uint64_t max_c = n_compartments;

      if (!uniform_init)
      {
        min_c = 0;
        max_c = 1;
      }

      // double reactor_total_mass = x0 * unit->domain.getTotalVolume();

      // Kokkos::View<double,ComputeSpace> view_reactor_total_mass("view_reactor_total_mass");
      // Kokkos::deep_copy(view_reactor_total_mass,reactor_total_mass);

      /*
       * The mass of each cell in the reactor can be calculated after the model initialization.
       * To ensure that each cell has a unique weight based on the total mass, the following formula
       * is used: weight = XV / m_tot Where: XV  - represents a certain property or value related to
       * the cell (e.g., volume, particle count, etc.). m_tot - the total mass of the cell or
       * reactor, which needs to be determined first.
       *
       * In order to compute the weight correctly, the initialization process needs to be split into
       * two phases:
       * 1. The first phase is to calculate the total mass of the cell (m_tot).
       * 2. The second phase is to apply the newly calculated weight to the cell using the formula
       * above.
       *
       * This split ensures that the mass is determined before the weight, as the weight is
       * dependent on the total mass.
       */

      Kokkos::parallel_reduce(
          "mc_init_first",
          Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, particle_per_process),
          KOKKOS_LAMBDA(const int i, double& local_mass) {
            auto p = Particle<Model>(1.);
            p.properties.id = i;
            const uint64_t location = rng.uniform_u(min_c, max_c);
            p.properties.current_container = location;
            Kokkos::atomic_increment(&compartments(location).n_cells);
            p.init(particle_rng);
            const double mass_i = p.data.mass();
            // Add the mass of the particle to the local mass variable
            local_mass += mass_i;
            // p.properties.weight = view_reactor_total_mass()/mass_i;
            // Store the particle in the list
            list.set(i, std::move(p));
          },
          total_mass // This is the result that will accumulate after the reduction
      );
      Kokkos::fence();

      unit->container = container;
    }

  } // namespace

  /**
   * @brief Helper function to initialize a MonteCarloUnit.
   *
   * Since MonteCarloUnit is not a generic type and the model type is resolved
   * at runtime, no constructors are defined to avoid carrying template
   * functions when using the unit. This function wraps the constructor
   * externally, providing a convenient way to initialize a MonteCarloUnit with
   * the appropriate model type and parameters.
   *
   * @tparam Model The particle model type, specified at compile time.
   *
   *
   * @return A unique pointer to the initialized MonteCarloUnit.
   */
  template <ParticleModel Model>
  std::unique_ptr<MonteCarloUnit> init(const ExecInfo& info,
                                       size_t n_particles,
                                       std::span<double> volumes,
                                       CmaRead::Neighbors::Neighbors_const_view_t neighbors,
                                       double x0,
                                       double& total_mass)
  {
    auto unit = std::make_unique<MonteCarloUnit>();

    unit->domain = ReactorDomain(volumes, neighbors);

    // Note: use size_t because number of particle represent actually an array size.
    std::size_t particle_per_process = n_particles / info.n_rank;

    const std::size_t remainder = n_particles % info.n_rank;
    if (remainder != 0 && info.current_rank == info.n_rank - 1)
    {
      particle_per_process += remainder;
    }
    constexpr double scale_factor = 1.;
    // const double weight = get_initial_weight(
    //     scale_factor, x0, unit->domain.getTotalVolume(), initial_mass_cell, n_particles);

    impl_init<Model>(unit, particle_per_process, total_mass);

    return unit;
  }

  inline void post_init_weight(std::unique_ptr<MonteCarloUnit>& unit, double x0, double total_mass)
  {

    const double new_weight = (x0 * unit->domain.getTotalVolume()) / (total_mass);
    KOKKOS_ASSERT(new_weight > 0);
    auto functor = [total_mass, new_weight](auto& container)
    {
      auto& list = container.get_compute();

      Kokkos::View<double, ComputeSpace> view_new_weight("view_new_weight");
      Kokkos::deep_copy(view_new_weight, new_weight);
      Kokkos::parallel_for("mc_init_apply",
                           Kokkos::RangePolicy<ComputeSpace>(0, list.size()),
                           PostInitFunctor(list, new_weight));
    };

    unit->init_weight = new_weight;
    std::visit(functor, unit->container);
  }

} // namespace MC

#endif //__MC_INIT_HPP__
