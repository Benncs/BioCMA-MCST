#ifndef __MC_INIT_HPP__
#define __MC_INIT_HPP__

#include "mc/domain.hpp"
#include <cassert>
#include <common/execinfo.hpp>
#include <common/kokkos_vector.hpp>
#include <cstdint>
#include <mc/particles/extra_process.hpp>
#include <mc/particles/mcparticles.hpp>
#include <mc/particles/particles_container.hpp>
#include <mc/prng/prng.hpp>
#include <mc/unit.hpp>
#include <memory>
#include <utility>

namespace MC
{

  // constexpr bool uniform_init = true;
  
  // namespace
  // {
    // /**
    //  * @brief helper function to get initial particle weight
    //  */
    // inline double get_initial_weight(double scale_factor,
    //                                  double particle_concentration,
    //                                  double total_volume,
    //                                  double mass_cell,
    //                                  size_t n_particles)
    // {
    //   // Scale factor is a fine tunning adjustement in case of misprediction of
    //   // particle weight particle_concentration is expected to be the real cell
    //   // concentration in g/L (kg/m3) Total volume is expected to be in m3 As a
    //   // result we can calculate the mass carried by each MC particle
    //   return scale_factor * particle_concentration * total_volume /
    //          static_cast<double>(n_particles) / mass_cell;
    // }

    //   /**
    //    */
    //   template <ParticleModel Model>
    //   void impl_init(std::unique_ptr<MonteCarloUnit>& unit,
    //                  uint64_t particle_per_process,
    //                  double& total_mass)
    //   {

    //     auto container = ParticlesContainer<Model>(particle_per_process);
    //     auto& list = container.get_compute();

    //     auto rng = unit->rng;
    //     auto particle_rng = list.rng_instance;

    //     list.set_allocation_factor(AutoGenerated::default_particle_container_allocation_factor);
    //     const auto n_compartments = unit->domain.getNumberCompartments();

    //     uint64_t min_c = 0;
    //     uint64_t max_c = n_compartments;

    //     if (!uniform_init)
    //     {
    //       min_c = 0;
    //       max_c = 1;
    //     }

    //     /*
    //      * The mass of each cell in the reactor can be calculated after the model initialization.
    //      * To ensure that each cell has a unique weight based on the total mass, the following
    //      formula
    //      * is used: weight = XV / m_tot Where: XV  - represents a certain property or value
    //      related to
    //      * the cell (e.g., volume, particle count, etc.). m_tot - the total mass of the cell or
    //      * reactor, which needs to be determined first.
    //      *
    //      * In order to compute the weight correctly, the initialization process needs to be split
    //      into
    //      * two phases:
    //      * 1. The first phase is to calculate the total mass of the cell (m_tot).
    //      * 2. The second phase is to apply the newly calculated weight to the cell using the
    //      formula
    //      * above.
    //      *
    //      * This split ensures that the mass is determined before the weight, as the weight is
    //      * dependent on the total mass.
    //      */

    //     Kokkos::parallel_reduce(
    //         "mc_init_first",
    //         Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, particle_per_process),
    //         KOKKOS_LAMBDA(const int i, double& local_mass) {
    //           auto p = Particle<Model>(1.);
    //           p.properties.id = i;
    //           const uint64_t location = rng.uniform_u(min_c, max_c);
    //           p.properties.current_container = location;
    //           p.init(particle_rng);
    //           const double mass_i = p.data.mass();
    //           local_mass += mass_i;
    //           list.set(i, std::move(p));
    //         },
    //         total_mass);
    //     Kokkos::fence();

    //     unit->container = container;
    //   }

    // } // namespace
    void impl_init(double& total_mass,uint64_t n_particles,MonteCarloUnit& unit,AutoGenerated::ContainerVariant&& container);
    /**
     * @brief Helper function to initialize a MonteCarloUnit.
     *
     * Since MonteCarloUnit is not a generic type and the model type is resolved
     * at runtime, no constructors are defined to avoid carrying template
     * functions when using the unit. This function wraps the constructor
     * externally, providing a convenient way to initialize a MonteCarloUnit with
     * the appropriate model type and parameters.
     *
     * @tparam Model The particle model type, specified at compile time.
     *
     *
     * @return A unique pointer to the initialized MonteCarloUnit.
     */
    template <ParticleModel Model>
    std::unique_ptr<MonteCarloUnit> init(const ExecInfo& info,
                                         uint64_t n_particles,
                                         std::span<double> volumes,
                                         const NeighborsView<HostSpace>& neighbors,
                                         double& total_mass)
    {
      auto unit = std::make_unique<MonteCarloUnit>();
      unit->domain = ReactorDomain(volumes, neighbors);
      auto container = ParticlesContainer<Model>(n_particles);
      impl_init(total_mass, n_particles, *unit, std::move(container));
      return unit;

      // auto& list = container.get_compute();
    
      // auto rng = unit->rng;
      // auto particle_rng = list.rng_instance;

      // list.set_allocation_factor(AutoGenerated::default_particle_container_allocation_factor);
      // const auto n_compartments = unit->domain.getNumberCompartments();

      // uint64_t min_c = 0;
      // uint64_t max_c = n_compartments;

      // if (!uniform_init)
      // {
      //   min_c = 0;
      //   max_c = 1;
      // }

      // /*
      //  * The mass of each cell in the reactor can be calculated after the model initialization.
      //  * To ensure that each cell has a unique weight based on the total mass, the following formula
      //  * is used: weight = XV / m_tot Where: XV  - represents a certain property or value related to
      //  * the cell (e.g., volume, particle count, etc.). m_tot - the total mass of the cell or
      //  * reactor, which needs to be determined first.
      //  *
      //  * In order to compute the weight correctly, the initialization process needs to be split into
      //  * two phases:
      //  * 1. The first phase is to calculate the total mass of the cell (m_tot).
      //  * 2. The second phase is to apply the newly calculated weight to the cell using the formula
      //  * above.
      //  *
      //  * This split ensures that the mass is determined before the weight, as the weight is
      //  * dependent on the total mass.
      //  */

      // Kokkos::parallel_reduce(
      //     "mc_init_first",
      //     Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, n_particles),
      //     KOKKOS_LAMBDA(const int i, double& local_mass) {
      //       auto p = Particle<Model>(1.);
      //       p.properties.id = i;
      //       const uint64_t location = rng.uniform_u(min_c, max_c);
      //       p.properties.current_container = location;
      //       p.init(particle_rng);
      //       const double mass_i = p.data.mass();
      //       local_mass += mass_i;
      //       list.set(i, std::move(p));
      //     },
      //     total_mass);
      // Kokkos::fence();

      // unit->container = container;
      // return unit;
    }

    void post_init_weight(std::unique_ptr<MonteCarloUnit>& unit, double x0, double total_mass);

  } // namespace MC

#endif //__MC_INIT_HPP__
