#include <Kokkos_Core.hpp>
#include <cma_utils/iteration_state.hpp>
#include <common/common.hpp>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <eigen_kokkos.hpp>
#include <mc/domain.hpp>
#include <mc/events.hpp>
#include <mc/prng/prng.hpp>
#include <mc/unit.hpp>
#include <memory>
#include <optional>
#include <scalar_simulation.hpp>
#include <simulation/alias.hpp>
#include <simulation/feed_descriptor.hpp>
#include <simulation/mass_transfer.hpp>
#include <simulation/probe.hpp>
#include <simulation/scalar_initializer.hpp>
#include <simulation/simulation.hpp>
#include <simulation/simulation_exception.hpp>
#include <traits/Kokkos_IterationPatternTrait.hpp>
#include <utility>
#ifndef NDEBUG
#  pragma GCC diagnostic push
#  pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#  pragma GCC diagnostic ignored "-Wnan-infinity-disabled"
#endif
#include <Eigen/Core>
#include <Eigen/Dense>
#include <Eigen/Sparse>
#ifndef NDEBUG
#  pragma GCC diagnostic pop
#endif
#include <hydro/impl_mass_transfer.hpp>

namespace Simulation
{
  std::size_t SimulationUnit::dead_counter() const
  {
    return internal_counter_dead;
  }

  bool SimulationUnit::two_phase_flow() const
  {
    return is_two_phase_flow;
  }

  DiagonalView<ComputeSpace> SimulationUnit::get_kernel_diagonal() const
  {

    return state.liq->get_kernel_diagonal();
  }
  kernelContribution SimulationUnit::get_kernel_contribution() const
  {
    return this->liquid_scalar->get_kernel_contribution();
  }

  [[nodiscard]] double& SimulationUnit::get_start_time_mut()
  {
    return starting_time;
  }
  [[nodiscard]] double& SimulationUnit::get_end_time_mut()
  {
    return end_time;
  }

  const Simulation::Feed::SimulationFeed& SimulationUnit::get_feed() const
  {
    return this->feed;
  }

  void SimulationUnit::setLogger(std::shared_ptr<IO::Logger> _logger)
  {
    logger = std::move(_logger);
  }

  void SimulationUnit::setMtrModel(MassTransfer::Type::MtrTypeVariant&& variant)
  {
    if (is_two_phase_flow)
    {
      this->mt_model = Simulation::MassTransfer::MassTransferModel(
          std::move(variant), liquid_scalar, gas_scalar);
    }
  }

  void SimulationUnit::setProbes(ProbeAutogeneratedBuffer&& _probes)
  {
    probes[ProbeType::LeavingTime] = std::move(_probes);
  }

  CumulativeProbabilityView<ComputeSpace>
  SimulationUnit::get_kernel_cumulative_proba() const
  {
    auto& matrix = state.liq->cumulative_probability;
    using layout_type = CumulativeProbabilityView<HostSpace>::array_layout;
    CumulativeProbabilityView<HostSpace> rd(
        matrix.data(), layout_type(matrix.rows(), matrix.cols()));

    return Kokkos::create_mirror_view_and_copy(ComputeSpace(), rd);
  }

  void SimulationUnit::set_kernel_contribs_to_host()
  {
    this->liquid_scalar->set_kernel_contribs_to_host();
  }

  [[nodiscard]] MC::KernelConcentrationType
  SimulationUnit::getkernel_concentration() const
  {
    return this->liquid_scalar->get_device_concentration();
  }

  std::span<const double> SimulationUnit::getContributionData() const
  {
    return liquid_scalar->getContributionData();
  }

  std::span<double> SimulationUnit::getContributionData_mut()
  {
    return this->liquid_scalar->getContributionData_mut();
  }

  std::span<double> SimulationUnit::getCliqData() const
  {
    return this->liquid_scalar->getConcentrationData();
  }

  [[nodiscard]] std::optional<std::span<const double>>
  SimulationUnit::getCgasData() const
  {
    if (!gas_scalar)
    {
      return std::nullopt;
    }
    return this->gas_scalar->getConcentrationData();
  }

  [[nodiscard]] Dimensions SimulationUnit::getDimensions() const noexcept
  {
    return {this->liquid_scalar->n_row(), this->liquid_scalar->n_col()};
  }

  [[nodiscard]] std::optional<std::span<const double>>
  SimulationUnit::getMTRData() const
  {
    return this->mt_model.mtr_data();
  }

  ProbeAutogeneratedBuffer& SimulationUnit::get_probes()
  {
    return probes[ProbeType::LeavingTime];
  }

  const CmaUtils::IterationState& SimulationUnit::getState() const
  {
    return state;
  }

} // namespace Simulation