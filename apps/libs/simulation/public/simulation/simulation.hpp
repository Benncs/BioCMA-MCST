#ifndef __SIMULATIONS_UNIT_HPP__
#define __SIMULATIONS_UNIT_HPP__

#include "mc/domain.hpp"
#include <Kokkos_Core.hpp>
#include <Kokkos_ScatterView.hpp>
#include <biocma_cst_config.hpp>
#include <cassert>
#include <cma_utils/iteration_state.hpp>
#include <common/common.hpp>
#include <cstddef>
#include <cstdint>
#include <mc/events.hpp>
#include <mc/prng/prng.hpp>
#include <mc/unit.hpp>
#include <memory>
#include <optional>
#include <simulation/alias.hpp>
#include <simulation/feed_descriptor.hpp>
#include <simulation/mass_transfer.hpp>
#include <simulation/move_kernel.hpp>
#include <simulation/probe.hpp>
#include <simulation/scalar_initializer.hpp>
#include <simulation/simulation_kernel.hpp>

#include <common/logger.hpp>

// TODO Clean
static constexpr size_t trigger_const_particle_number = 1e6;
static constexpr bool f_reaction = true; // FIXME

namespace CmaUtils
{
  class PreCalculatedHydroState;
} // namespace CmaUtils

/**
 * @namespace Simulation
 * @brief Namespace that contains classes and structures related to simulation
 * handling
 */
namespace Simulation
{

  struct Dimensions
  {
    std::size_t n_species{};
    std::size_t n_compartment{};

    template <class Archive> void serialize(Archive& archive)
    {
      archive(n_species, n_compartment);
    }
  };

  class ScalarSimulation;

  class SimulationUnit
  {
  public:
    SimulationUnit(std::unique_ptr<MC::MonteCarloUnit>&& _unit,
                   const ScalarInitializer& scalar_init,
                   std::optional<Feed::SimulationFeed> _feed = std::nullopt);

    ~SimulationUnit();

    SimulationUnit(SimulationUnit&& other) noexcept;
    SimulationUnit(const SimulationUnit& other) = delete;
    SimulationUnit& operator=(SimulationUnit&& rhs) = delete;
    SimulationUnit& operator=(const SimulationUnit& rhs) = delete;

    std::unique_ptr<MC::MonteCarloUnit> mc_unit; // NOLINT

    [[nodiscard]] const Simulation::Feed::SimulationFeed& get_feed() const;
    ProbeAutogeneratedBuffer& get_probes();

    // std::span<double> getContributionData_mut();

    // Setters
    void setProbes(ProbeAutogeneratedBuffer&& _probes);
    void setMtrModel(MassTransfer::Type::MtrTypeVariant&& variant);
    void setLogger(std::shared_ptr<IO::Logger>);

    // Getters
    [[nodiscard]] double& get_start_time_mut();
    [[nodiscard]] double& get_end_time_mut();
    [[nodiscard]] const CmaUtils::IterationState& getState() const;
    [[nodiscard]] Dimensions getDimensions() const noexcept;
    [[nodiscard]] std::span<double> getCliqData() const;
    [[nodiscard]] std::optional<std::span<const double>> getCgasData() const;
    [[nodiscard]] std::span<const double> getContributionData() const;
    [[nodiscard]] bool two_phase_flow() const;
    [[nodiscard]] std::optional<std::span<const double>> getMTRData() const;
    [[nodiscard]] std::size_t dead_counter() const;

    // Simulation methods

    void cycleProcess(auto&& container, double d_t);

    void step(double d_t) const;
    void reduceContribs(std::span<const double> data, size_t n_rank) const;
    [[deprecated("perf:not useful")]] void
    reduceContribs_per_rank(std::span<const double> data) const;
    void clearContribution() const noexcept;
    auto init_functor(double d_t, auto&& container);
    void update_feed(double t, double d_t, bool update_scalar = true) noexcept;
    void update(CmaUtils::IterationState&& new_state);

    // Memory management
    void clear_mc();
    void reset();
    void post_init_compartments();

  private:
    void setVolumes() const;
    void setLiquidFlow(CmaUtils::PreCalculatedHydroState* _flows_l);
    void setGasFlow(CmaUtils::PreCalculatedHydroState* _flows_g);

    [[nodiscard]] MC::KernelConcentrationType getkernel_concentration() const;

    MC::ContributionView contribs_scatter;
    MapProbes probes;

    // Attributes
    std::size_t internal_counter_dead;
    uint64_t minimum_dead_particle_removal;
    // ProbeAutogeneratedBuffer probes;
    Simulation::Feed::SimulationFeed feed;

    CmaUtils::IterationState state;
    bool const_number_simulation = true;
    bool is_two_phase_flow;
    double starting_time = 0.; // Not used within calculation, only for export purposes
    double end_time{};         // Not used within calculation, only for export purposes

    // Bounce methods to pimpl
    [[nodiscard]] DiagonalView<ComputeSpace> get_kernel_diagonal() const;
    [[nodiscard]] CumulativeProbabilityView<ComputeSpace> get_kernel_cumulative_proba() const;
    [[nodiscard]] kernelContribution get_kernel_contribution() const;

    void set_kernel_contribs_to_host();
    void post_init_concentration(const ScalarInitializer& scalar_init);
    void post_init_concentration_functor(const ScalarInitializer& scalar_init);
    void post_init_concentration_file(const ScalarInitializer& scalar_init);

    std::shared_ptr<ScalarSimulation> liquid_scalar;
    std::shared_ptr<ScalarSimulation> gas_scalar;
    MassTransfer::MassTransferModel mt_model; // TODO add default null value (no model)
    KernelInline::MoveInfo<ComputeSpace> move_info;

    void scatter_contribute();

    std::shared_ptr<IO::Logger> logger;

    template <ModelType Model>
    void post_cycle(MC::ParticlesContainer<Model>& container,
                    std::size_t n_particle,
                    KernelInline::Functors::move_reducer_view_type& out_total,
                    KernelInline::Functors::cycle_reducer_view_type& reducer_type);

    template <ModelType Model> void pre_cycle(MC::ParticlesContainer<Model>& container, double d_t);
  };

  template <ModelType Model>
  void SimulationUnit::pre_cycle(MC::ParticlesContainer<Model>& container, double d_t)
  {

    this->move_info.cumulative_probability = get_kernel_cumulative_proba();
    this->move_info.diag_transition = get_kernel_diagonal();
    this->move_info.neighbors = mc_unit->domain.getNeighbors();
  }

  void SimulationUnit::cycleProcess(auto&& container, double d_t)
  {

    PROFILE_SECTION("cycleProcess")
    using CurrentModel = typename std::remove_reference<decltype(container)>::type::UsedModel;
    const size_t n_particle = container.n_particles();
    if (n_particle == 0)
    {
      return;
    }

    pre_cycle(container, d_t);

    auto local_rng = mc_unit->rng;
    auto events = mc_unit->events;
    auto contribs = get_kernel_contribution();

    MC::ContributionView contribs_scatter(contribs);
    auto out_total = Kokkos::View<std::size_t, ComputeSpace>("out_total");

    auto reaction_functor = Simulation::KernelInline::CycleFunctor<CurrentModel>(
        d_t, container, local_rng.random_pool, getkernel_concentration(), contribs_scatter, events);

    auto reducer = KernelInline::CycleReducer<ComputeSpace>::result_view_type("reducer");

    auto _policy = MC::get_policy(reaction_functor, n_particle, true);

    bool enable_move = move_info.liquid_volume.size() > 1;
    bool enable_leave = move_info.leaving_flow.size() != 0;

    Kokkos ::parallel_reduce(
        "cycle_move",
        _policy,
        Simulation ::KernelInline ::MoveFunctor(d_t,
                                                container.position,
                                                container.status,
                                                n_particle,
                                                move_info,
                                                local_rng.random_pool,
                                                events,
                                                probes[ProbeType ::LeavingTime],
                                                container.ages,
                                                enable_move,
                                                enable_leave),
        out_total);

    if (f_reaction)
    {

      Kokkos::parallel_reduce("cycle_model",
                              _policy,
                              reaction_functor,
                              KernelInline::CycleReducer<ComputeSpace>(reducer));
    }

    Kokkos::Experimental::contribute(contribs, contribs_scatter);

    post_cycle(container, n_particle, out_total, reducer);
  }

  template <ModelType Model>
  void SimulationUnit::post_cycle(MC::ParticlesContainer<Model>& container,
                                  std::size_t n_particle,
                                  KernelInline::Functors::move_reducer_view_type& out_total,
                                  KernelInline::Functors::cycle_reducer_view_type& reducer_type)
  {
    const auto threshold =
        std::max(minimum_dead_particle_removal,
                 static_cast<uint64_t>(static_cast<double>(n_particle) *
                                       AutoGenerated::dead_particle_ratio_threshold));

    Kokkos::fence();
    auto host_red = Kokkos::create_mirror_view_and_copy(HostSpace(), reducer_type)();
    auto host_out_counter = Kokkos::create_mirror_view_and_copy(HostSpace(), out_total)();
    container.counter += host_out_counter;
    container.counter += host_red.dead_total;

    // TODO: May change threshold as container is now cleaned before exporting,
    if (container.counter > threshold)
    {
      container.clean_dead(container.counter);
      container.counter = 0;
    }
    internal_counter_dead = container.counter;

    container.merge_buffer();

    if (host_red.waiting_allocation_particle != 0)
    {
      if (logger)
      {
        logger->alert(
            "Simulation",
            "Overflow of particle not implemented yet (ignore _waiting_allocation_particle)");
      }
    }

    set_kernel_contribs_to_host();
  }

} // namespace Simulation

#endif //__SIMULATIONS_UNIT_HPP__
