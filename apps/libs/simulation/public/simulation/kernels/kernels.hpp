#ifndef __SIMULATION_KERNELS_HPP__
#define __SIMULATION_KERNELS_HPP__

#include <common/kokkos_getpolicy.hpp>
#include <mc/unit.hpp>
#include <simulation/kernels/model_kernel.hpp>
#include <simulation/kernels/move_kernel.hpp>
namespace Simulation::KernelInline
{
  template <typename Space>
  using cycle_reducer_view_type =
      KernelInline::CycleReducer<Space>::result_view_type;
  template <typename Space>
  using move_reducer_view_type = Kokkos::View<std::size_t, Space>;

  template <typename Space, ModelType Model> struct CycleFunctors
  {
    using FModel = Model;

    using cycle_kernel_type = CycleFunctor<Model>;
    using move_kernel_type = MoveFunctor;

    cycle_reducer_view_type<Space> cycle_reducer;
    move_reducer_view_type<Space> move_reducer;
    cycle_kernel_type cycle_kernel;
    move_kernel_type move_kernel;

    CycleFunctors() = default;

    void update(double d_t,
                MC::ParticlesContainer<Model> container,
                MoveInfo<ComputeSpace> new_move)
    {
      bool enable_move = new_move.liquid_volume.size() > 1;
      bool enable_leave = new_move.leaving_flow.size() != 0;

      // FIXME: cycle_kernel: need to update container because we change:
      // n_used_element counter which is size_t outside of kernel. As functor
      // owns a copy of container this counter is not update between iterations.
      // 1. Use n_used_element as a reference counter type
      // 2. Manually update counter in update function (dirty way)

      cycle_kernel.update(d_t, container);

      // TODO: Why need to update all views (where did we lost the refcount ? )
      move_kernel.update(d_t,
                         container.n_particles(),
                         std::move(new_move),
                         container.position,
                         container.status,
                         container.ages,
                         enable_move,
                         enable_leave);
    }

    auto get_host_reduction()
    {
      const auto host_red =
          Kokkos::create_mirror_view_and_copy(HostSpace(), cycle_reducer)();

      const auto host_out_counter =
          Kokkos::create_mirror_view_and_copy(HostSpace(), move_reducer)();

      return std::tuple(host_red, host_out_counter);
    }

    CycleFunctors(MC::ParticlesContainer<Model> container,
                  MC::KPRNG::pool_type _random_pool,
                  MC::KernelConcentrationType&& _concentrations,
                  MC::ContributionView _contribs_scatter,
                  MC::EventContainer _event,
                  MoveInfo<ComputeSpace> m,
                  ProbeAutogeneratedBuffer _probes)
        : cycle_reducer("cycle_reducer"), move_reducer("move_reducer"),
          cycle_kernel(container,
                       _random_pool,
                       std::move(_concentrations),
                       _contribs_scatter,
                       _event),
          move_kernel(container.position,
                      container.status,
                      std::move(m),
                      _random_pool,
                      _event,
                      _probes,
                      container.ages)
    {
    }

    void launch_move(const std::size_t n_particle) const
    {

      if (move_kernel.enable_move)
      {
        // const auto _policy_move =
        //     Common::get_policy<move_kernel_type, KernelInline::TagMove>(
        //         move_kernel, n_particle, false);
        const auto _policy_move =
            Common::get_policy<KernelInline::TagMove>(n_particle, false);

        Kokkos ::parallel_for("cycle_move", _policy_move, move_kernel);
      }
      if (move_kernel.enable_leave)
      {

        const auto _policy_leave =
            Kokkos::TeamPolicy<ComputeSpace, KernelInline::TagLeave>(
                256, Kokkos::AUTO);

        Kokkos ::parallel_reduce(
            "cycle_move_leave", _policy_leave, move_kernel, move_reducer);
      }
    }

    void launch_model(const std::size_t n_particle) const
    {
      constexpr bool is_reduce = true;
      // const auto _policy =
      //     Common::get_policy<cycle_kernel_type, KernelInline::TagSecondPass>(
      //         cycle_kernel, n_particle, is_reduce);
      //
      const auto _policy = Common::get_policy<KernelInline::TagSecondPass>(
          n_particle, is_reduce);

      const auto scatter_policy =
          Kokkos::RangePolicy<KernelInline::TagFirstPass>(0, n_particle);

      Kokkos::parallel_reduce(
          "cycle_model",
          _policy,
          cycle_kernel,
          KernelInline::CycleReducer<ComputeSpace>(cycle_reducer));
      Kokkos::fence(); // TODO needed ?
      Kokkos::parallel_for("cycle_scatter", scatter_policy, cycle_kernel);
    }
  };

} // namespace Simulation::KernelInline

#endif
