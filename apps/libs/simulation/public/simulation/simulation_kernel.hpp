#ifndef __SIMULATION_MC_KERNEL_HPP
#define __SIMULATION_MC_KERNEL_HPP

#include <Kokkos_Core.hpp>
#include <Kokkos_Random.hpp>
#include <biocma_cst_config.hpp>
#include <cassert>
#include <common/kokkos_vector.hpp>
#include <mc/container_state.hpp>
#include <mc/domain.hpp>
#include <mc/events.hpp>
#include <mc/particles/data_holder.hpp>
#include <mc/particles/mcparticles.hpp>
#include <mc/prng/prng.hpp>
#include <simulation/alias.hpp>
#include <simulation/probability_leaving.hpp>
#include <simulation/probe.hpp>
#include <utility>
static constexpr bool const_number_simulation = false;

namespace Simulation::KernelInline
{

  template <typename ExecSpace> struct MoveInfo
  {
    NeighborsView<ExecSpace> neighbors;
    DiagonalView<ExecSpace> diag_transition;
    CumulativeProbabilityView<ExecSpace> cumulative_probability;
    LeavingFlowType leaving_flow;
    LeavingFlowIndexType index_leaving_flow;
    Kokkos::View<double*, ExecSpace> liquid_volume;
  };

  // };

  struct TagDetector
  {
    KOKKOS_FUNCTION void
    operator()(const Kokkos::TeamPolicy<ComputeSpace>::member_type& team_handle,
               int& dead_count) const
    {
      (void)team_handle;
      (void)dead_count;
    }
    TagDetector()
    {
    }
  };

  using GeneratorPool = Kokkos::Random_XorShift64_Pool<>;
  template <typename ListType> class Kernel
  {

  public:
    KOKKOS_FUNCTION void
    operator()(const Kokkos::TeamPolicy<ComputeSpace>::member_type& team_handle,
               int& dead_count,
               int& waiting_allocation_particle) const;
    Kernel(double _d_t,
           ListType _list,
           ListType _extra,
           //  MC::ReactorDomain::n_cells_view_type _n_cells,
           Kokkos::View<const double**,
                        Kokkos::LayoutLeft,
                        ComputeSpace,
                        Kokkos::MemoryTraits<Kokkos::RandomAccess>> _concentrations,
           MoveInfo<ComputeSpace> _move_info,
           MC::EventContainer _events,
           ContributionView _biomass_contribution,
           ProbeAutogeneratedBuffer prob,
           MC::KPRNG pool)
        : d_t(_d_t), list(_list), extra(std::move(_extra)),
          //  n_cells(std::move(_n_cells)),
          concentrations(std::move(_concentrations)), move_info(std::move(_move_info)),
          rng_pool(std::move(pool)), events(std::move(_events)),
          biomass_contribution(std::move(_biomass_contribution)), probe_at_t(std::move(prob))
    {
    }

  private:
    double d_t{};
    ListType list;
    ListType extra;
    // MC::ReactorDomain::n_cells_view_type n_cells;
    MoveInfo<ComputeSpace> move_info;
    MC::KPRNG rng_pool;

    decltype(Kokkos::subview(move_info.neighbors, 1, Kokkos::ALL)) subviewn;
    Kokkos::View<const double**,
                 Kokkos::LayoutLeft,
                 ComputeSpace,
                 Kokkos::MemoryTraits<Kokkos::RandomAccess>>
        concentrations;
    MC::EventContainer events;
    ContributionView biomass_contribution;

    ProbeAutogeneratedBuffer probe_at_t;

    KOKKOS_FUNCTION void handle_division(auto& particle, int& waiting_allocation_particle) const
    {

      if (particle.properties.status == MC::CellStatus::CYTOKINESIS)
      {
        events.template incr<MC::EventType::NewParticle>();

        auto new_particle = particle.division(rng_pool);
        KOKKOS_ASSERT(new_particle.properties.status != MC::CellStatus::CYTOKINESIS);

        if constexpr (!const_number_simulation)
        {

          if (!extra.emplace(std::move(new_particle)))
          {
            Kokkos::printf("SPAWNING OVERFLOW\r\n");
            waiting_allocation_particle += 1;
          }
        }
        else
        {
          particle.properties.weight *= 2;
        }

        KOKKOS_ASSERT(particle.properties.status != MC::CellStatus::CYTOKINESIS);
      }
    }

    KOKKOS_FUNCTION void handle_move(MC::ParticleDataHolder& properties) const;

    KOKKOS_FUNCTION void handle_exit(auto& status, MC::ParticleDataHolder& properties) const
    {
      for (size_t i = 0LU; i < move_info.index_leaving_flow.size(); ++i)
      {
        // const double random_number = //local_rng.double_uniform();

        auto generator = rng_pool.random_pool.get_state();
        const float random_number = generator.frand(0., 1.);
        rng_pool.random_pool.free_state(generator);

        const auto& index = move_info.index_leaving_flow(i);
        const auto& flow = move_info.leaving_flow(i);
        if (properties.current_container != index || status != MC::CellStatus::IDLE)
        {
          return;
        }

        if (probability_leaving(random_number, move_info.liquid_volume(index), flow, d_t))
        {

          if constexpr (AutoGenerated::FlagCompileTime::use_probe)
          {
            // Ignore ret value, if probe is full were gonna miss events which is not really
            // important
            auto _ = probe_at_t.set(properties.hydraulic_time);
          }

          properties.reset();
          status = MC::CellStatus::OUT;
        }
      }
    }

    [[nodiscard]] KOKKOS_INLINE_FUNCTION size_t __find_next_compartment(std::size_t i_compartment,
                                                                        double random_number) const;
  };

  /****************
  ** IMPL KERNEL **
  *****************/

  template <typename ListType>
  KOKKOS_FUNCTION void
  Kernel<ListType>::operator()(const Kokkos::TeamPolicy<ComputeSpace>::member_type& team_handle,
                               int& dead_count,
                               int& waiting_allocation_particle) const
  {
    int idx = team_handle.league_rank() * team_handle.team_size() + team_handle.team_rank();
    if (idx >= list.size())
    {
      return;
    }

    auto& particle = list._owned_data[idx];
    auto& status = particle.properties.status;
    auto& properties = particle.properties;

    // // // TODO Test attribute
    if (status == MC::CellStatus::DEAD) [[unlikely]]
    {
      // This warp divergence is not a priori a problem because it is a
      // cold branch
      return;
    }

    handle_move(properties);

    handle_exit(status, properties);

    // // // Useless to try to reducing branhcing here because we're going to
    // // // early return so serializing will occur
    if (status == MC::CellStatus::OUT)
    {
      events.template incr<MC::EventType::Exit>();
      status = MC::CellStatus::DEAD;
      dead_count = +1;
      return;
    }
    particle.update(
        d_t, Kokkos::subview(concentrations, Kokkos::ALL, properties.current_container), rng_pool);

    particle.contribution(biomass_contribution);

    handle_division(particle, waiting_allocation_particle);
  }

  template <typename ListType>
  KOKKOS_FUNCTION void Kernel<ListType>::handle_move(MC::ParticleDataHolder& properties) const
  {
    const size_t i_compartment = properties.current_container;

    // Need 2 random numbers, use index 0 and 1 to acess to
    auto generator = rng_pool.random_pool.get_state();
    const float rng1 = generator.frand(0., 1.);
    const double rng2 = generator.drand(0., 1.);
    rng_pool.random_pool.free_state(generator);
    const bool mask_next = probability_leaving(rng1,
                                               move_info.liquid_volume(i_compartment),
                                               move_info.diag_transition(i_compartment),
                                               d_t);

    // properties.current_container = (mask_next)?__find_next_compartment(i_compartment, rng2):i_compartment;
    if (mask_next)
    {
      properties.current_container = __find_next_compartment(i_compartment, rng2);
      events.template incr<MC::EventType::Move>();
    }
  };

  /**
   * @brief Finds the next compartment for a particle based on a random number
   * and cumulative probabilities.
   *
   * This function determines the next compartment for a particle by comparing a
   * random number against the cumulative probabilities of the neighboring
   * compartments. It returns the index of the chosen next compartment based on
   * the transition probabilities.
   *
   * @param i_compartment Index of the current compartment.
   * @param random_number Random number used to decide the next compartment.
   * @param i_neighbor Span of indices representing neighboring compartments.
   * @param cumulative_probability 2D view of cumulative probabilities for the
   * compartments.
   *
   * @return The index of the next compartment for the particle.
   */
  // template <typename ListType>
  // KOKKOS_FUNCTION size_t Kernel<ListType>::__find_next_compartment(
  //     const std::size_t i_compartment,
  //     const double random_number,
  //     const Kokkos::View<const size_t*, Kokkos::LayoutStride, ComputeSpace>& i_neighbor) const
  // {
  //   const int max_neighbor = static_cast<int>(i_neighbor.size());
  //   size_t next = i_neighbor(0); // Default to the first neighbor
  //   // Iterate through the neighbors to find the appropriate next compartment
  //   for (int k_neighbor = 0; k_neighbor < max_neighbor - 1; ++k_neighbor)
  //   {
  //     // Get the cumulative probability range for the current neighbor
  //     const auto pi = move_info.cumulative_probability(i_compartment, k_neighbor);
  //     const auto pn = move_info.cumulative_probability(i_compartment, k_neighbor + 1);

  //     // Use of a Condition mask to avoid branching.
  //     // As the condition is not complex, ternary op manually guarantee that no
  //     // branching/warp divergence occurs
  //     next = (random_number <= pn && pi <= random_number) ? i_neighbor(k_neighbor + 1) : next;
  //   }

  //   return next; // Return the index of the chosen next compartment
  // }

  // TODO CHECK IF WORTH IT

  template <typename ListType>
  KOKKOS_INLINE_FUNCTION size_t Kernel<ListType>::__find_next_compartment(
      const std::size_t i_compartment, const double random_number) const
  {
    const int max_neighbor = static_cast<int>(move_info.neighbors.extent(1));
    size_t next = move_info.neighbors(i_compartment, 0); // Default to the first neighbor

    // Iterate through the neighbors to find the appropriate next compartment
    for (int k_neighbor = 0; k_neighbor < max_neighbor - 1; ++k_neighbor)
    {
      // Get the cumulative probability range for the current neighbor

      const auto pi = move_info.cumulative_probability(
          i_compartment, move_info.neighbors(i_compartment, k_neighbor));
      const auto pn = move_info.cumulative_probability(
          i_compartment, move_info.neighbors(i_compartment, k_neighbor + 1));

      // Use of a Condition mask to avoid branching.
      // As the condition is not complex, ternary op manually guarantee that no
      // branching/warp divergence occurs
      next = (random_number <= pn && pi <= random_number)
                 ? move_info.neighbors(i_compartment, k_neighbor + 1)
                 : next;
    }

    return next; // Return the index of the chosen next compartment
  }

} // namespace Simulation::KernelInline

#endif
