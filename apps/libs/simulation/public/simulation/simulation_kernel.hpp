#ifndef __SIMULATION_MC_KERNEL_HPP
#define __SIMULATION_MC_KERNEL_HPP

#include <Kokkos_Core.hpp>
#include <Kokkos_Random.hpp>
#include <biocma_cst_config.hpp>
#include <cassert>
#include <common/kokkos_vector.hpp>
#include <mc/container_state.hpp>
#include <mc/domain.hpp>
#include <mc/events.hpp>
#include <mc/particles/data_holder.hpp>
#include <mc/particles/mcparticles.hpp>
#include <mc/prng/prng.hpp>
#include <simulation/alias.hpp>
#include <simulation/probability_leaving.hpp>
#include <simulation/probe.hpp>
#include <utility>
static constexpr bool const_number_simulation = false;

namespace Simulation::KernelInline
{

  template <typename ExecSpace> struct MoveInfo
  {
    NeighborsView<ExecSpace> neighbors;
    DiagonalView<ExecSpace> diag_transition;
    CumulativeProbabilityView<ExecSpace> cumulative_probability;
    LeavingFlowType leaving_flow;
    LeavingFlowIndexType index_leaving_flow;
  };

  // template <typename ListType> struct KernelContrib
  // {
  //   KernelContrib(ListType _l,ContributionView _c):list(_l),biomass_contribution(std::move(_c))
  //   {

  //   }

  //   KOKKOS_FUNCTION void operator()(std::size_t i_particle) const
  //   {
  //     list._owned_data[i_particle].contribution(biomass_contribution);
  //   }
  //   ListType list;
  //   ContributionView biomass_contribution;
  // };

  struct TagDetector
  {
    KOKKOS_FUNCTION void
    operator()(const Kokkos::TeamPolicy<ComputeSpace>::member_type& team_handle,
               int& dead_count) const
    {
      (void)team_handle;
      (void)dead_count;
    }
    TagDetector()
    {
    }
  };

  using GeneratorPool = Kokkos::Random_XorShift64_Pool<>;
  template <typename ListType> class Kernel
  {

  public:
    // KOKKOS_FUNCTION void operator()(std::size_t i_particle,int& dead_count) const;
    KOKKOS_FUNCTION void
    operator()(const Kokkos::TeamPolicy<ComputeSpace>::member_type& team_handle,
               int& dead_count,
               int& waiting_allocation_particle) const;
    Kernel(double _d_t,
           ListType _list,
           ListType _extra,
           Kokkos::View<MC::ContainerState*, Kokkos::SharedSpace> _local_compartments,
           MoveInfo<ComputeSpace> _move_info,
           MC::EventContainer _events,
           ContributionView _biomass_contribution,
           ProbeAutogeneratedBuffer prob,
           MC::KPRNG pool)
        : d_t(_d_t), list(_list), extra(std::move(_extra)),
          local_compartments(std::move(_local_compartments)), move_info(std::move(_move_info)),
          rng_pool(std::move(pool)), events(std::move(_events)),
          biomass_contribution(std::move(_biomass_contribution)), probe_at_t(std::move(prob))
    {
    }

  private:
    double d_t{};
    ListType list;
    ListType extra;
    Kokkos::View<MC::ContainerState*, Kokkos::SharedSpace> local_compartments;
    MoveInfo<ComputeSpace> move_info;
    MC::KPRNG rng_pool;

    MC::EventContainer events;
    ContributionView biomass_contribution;

    ProbeAutogeneratedBuffer probe_at_t;

    KOKKOS_FUNCTION void handle_division(auto& particle,int& waiting_allocation_particle) const
    {

      if (particle.properties.status == MC::CellStatus::CYTOKINESIS)
      {
        events.template incr<MC::EventType::NewParticle>();

        auto new_particle = particle.division(rng_pool);
        KOKKOS_ASSERT(new_particle.properties.status != MC::CellStatus::CYTOKINESIS);

        if constexpr (!const_number_simulation)
        {

          if (!extra.emplace(std::move(new_particle)))
          {
            Kokkos::printf("SPAWNING OVERFLOW\r\n");
            // Kokkos::atomic_increment(&waiting_allocation_particle()); // TODO clean this
            waiting_allocation_particle+=1;
          }
        }
        else
        {
          particle.properties.weight *= 2;
          Kokkos::atomic_increment(
              &local_compartments(particle.properties.current_container).n_cells);
        }

        KOKKOS_ASSERT(particle.properties.status != MC::CellStatus::CYTOKINESIS);
      }
    }

    KOKKOS_FUNCTION void handle_move(MC::ParticleDataHolder& properties) const;

    KOKKOS_FUNCTION void handle_exit(auto& status, MC::ParticleDataHolder& properties) const
    {
      for (size_t i = 0LU; i < move_info.index_leaving_flow.size(); ++i)
      {
        // const double random_number = //local_rng.double_uniform();

        auto generator = rng_pool.random_pool.get_state();
        const float random_number = generator.frand(0., 1.);
        rng_pool.random_pool.free_state(generator);

        const auto& index = move_info.index_leaving_flow(i);
        const auto& flow = move_info.leaving_flow(i);
        if (properties.current_container != index || status != MC::CellStatus::IDLE)
        {
          return;
        }

        auto& current_container = local_compartments(index);
        if (probability_leaving(random_number, current_container.volume_liq, flow, d_t))
        {

          if constexpr (AutoGenerated::FlagCompileTime::use_probe)
          {
            // Ignore ret value, if probe is full were gonna miss events which is not really
            // important
            auto _ = probe_at_t.set(properties.hydraulic_time);
          }

          KOKKOS_ASSERT(Kokkos::atomic_load(&current_container.n_cells) > 0);
          Kokkos::atomic_sub(&current_container.n_cells, 1);
          properties.reset();
          status = MC::CellStatus::OUT;
        }
      }
    }

    [[nodiscard]] KOKKOS_INLINE_FUNCTION size_t __find_next_compartment(
        std::size_t i_compartment,
        double random_number,
        const Kokkos::View<const size_t*, Kokkos::LayoutStride, ComputeSpace>& i_neighbor) const;
  };

  /****************
  ** IMPL KERNEL **
  *****************/

  template <typename ListType>
  KOKKOS_FUNCTION void
  Kernel<ListType>::operator()(const Kokkos::TeamPolicy<ComputeSpace>::member_type& team_handle,
                               int& dead_count,int& waiting_allocation_particle) const
  {
    int idx = team_handle.league_rank() * team_handle.team_size() + team_handle.team_rank();
    if (idx >= list.size())
    {
      return;
    }

    auto& particle = list._owned_data[idx];
    auto& status = particle.properties.status;
    auto& properties = particle.properties;

    // // // TODO Test attribute
    if (status == MC::CellStatus::DEAD) [[unlikely]]
    {
      // This warp divergence is not a priori a problem because it is a
      // cold branch
      return;
    }

    handle_move(properties);

    handle_exit(status, properties);

    // // // Useless to try to reducing branhcing here because we're going to
    // // // early return so serializing will occur
    if (status == MC::CellStatus::OUT)
    {
      events.template incr<MC::EventType::Exit>();
      status = MC::CellStatus::DEAD;
      dead_count = +1;
      return;
    }

    particle.update(d_t, local_compartments(properties.current_container).concentrations, rng_pool);

    particle.contribution(biomass_contribution);

    handle_division(particle,waiting_allocation_particle);
  }

  // template <typename ListType>
  // KOKKOS_FUNCTION void Kernel<ListType>::operator()(const std::size_t i_particle,int& dead_count)
  // const
  // {

  //   auto& particle = list._owned_data[i_particle];
  //   auto& status = particle.properties.status;
  //   auto& properties = particle.properties;

  //   // // // TODO Test attribute
  //   if (status == MC::CellStatus::DEAD) [[unlikely]]
  //   {
  //     // This warp divergence is not a priori a problem because it is a
  //     // cold branch
  //     return;
  //   }

  //   // handle_move(properties);

  //   // handle_exit(status, properties);

  //   // // // Useless to try to reducing branhcing here because we're going to
  //   // // // early return so serializing will occur
  //   if (status == MC::CellStatus::OUT)
  //   {
  //     events.template incr<MC::EventType::Exit>();
  //     status = MC::CellStatus::DEAD;
  //     dead_count=+1;
  //     return;
  //   }

  //   particle.update(d_t, local_compartments(properties.current_container).concentrations,
  //   list.rng_instance);

  //   particle.contribution(biomass_contribution);

  //   handle_division(particle);
  // }

  template <typename ListType>
  KOKKOS_FUNCTION void Kernel<ListType>::handle_move(MC::ParticleDataHolder& properties) const
  {
    const size_t i_compartment = properties.current_container;
    auto& current_container = local_compartments(i_compartment);

    const auto i_neighbor = Kokkos::subview(move_info.neighbors, i_compartment, Kokkos::ALL);

    // Need 2 random numbers, use index 0 and 1 to acess to
    auto generator = rng_pool.random_pool.get_state();
    const float rng1 = generator.frand(0., 1.);
    const double rng2 = generator.drand(0., 1.);
    rng_pool.random_pool.free_state(generator);
    const bool mask_next = probability_leaving(
        rng1, current_container.volume_liq, move_info.diag_transition(i_compartment), d_t);

    if (mask_next)
    {
      const size_t next = __find_next_compartment(i_compartment, rng2, i_neighbor);
      
      KOKKOS_ASSERT(Kokkos::atomic_load(&current_container.n_cells) > 0);
      Kokkos::atomic_sub(&current_container.n_cells, 1);
      Kokkos::atomic_add(&local_compartments(next).n_cells, 1);

      properties.current_container = next;
      events.template incr<MC::EventType::Move>();
    }
  };

  /**
   * @brief Finds the next compartment for a particle based on a random number
   * and cumulative probabilities.
   *
   * This function determines the next compartment for a particle by comparing a
   * random number against the cumulative probabilities of the neighboring
   * compartments. It returns the index of the chosen next compartment based on
   * the transition probabilities.
   *
   * @param i_compartment Index of the current compartment.
   * @param random_number Random number used to decide the next compartment.
   * @param i_neighbor Span of indices representing neighboring compartments.
   * @param cumulative_probability 2D view of cumulative probabilities for the
   * compartments.
   *
   * @return The index of the next compartment for the particle.
   */
  template <typename ListType>
  KOKKOS_FUNCTION size_t Kernel<ListType>::__find_next_compartment(
      const std::size_t i_compartment,
      const double random_number,
      const Kokkos::View<const size_t*, Kokkos::LayoutStride, ComputeSpace>& i_neighbor) const
  {
    const int max_neighbor = static_cast<int>(i_neighbor.size());
    size_t next = i_neighbor(0); // Default to the first neighbor
    // Iterate through the neighbors to find the appropriate next compartment
    for (int k_neighbor = 0; k_neighbor < max_neighbor - 1; ++k_neighbor)
    {
      // Get the cumulative probability range for the current neighbor
      const auto pi = move_info.cumulative_probability(i_compartment, k_neighbor);
      const auto pn = move_info.cumulative_probability(i_compartment, k_neighbor + 1);

      // Use of a Condition mask to avoid branching.
      // As the condition is not complex, ternary op manually guarantee that no
      // branching/warp divergence occurs
      next = (random_number <= pn && pi <= random_number) ? i_neighbor(k_neighbor + 1) : next;
    }

    return next; // Return the index of the chosen next compartment
  }

  // TODO CHECK IF WORTH IT
  /*
  template <typename ListType, typename ResultViewType>
  KOKKOS_INLINE_FUNCTION size_t
  Kernel<ListType, ResultViewType>::_find_next_compartment_2(
      const std::size_t i_compartment,
      const double random_number,
      const NeighborsViewCompute
          &i_neighbor) const
  {
    const int max_neighbor = static_cast<int>(i_neighbor.size());
    size_t next = i_neighbor(i_compartment,0); // Default to the first neighbor

    // Iterate through the neighbors to find the appropriate next compartment
    for (int k_neighbor = 0; k_neighbor < max_neighbor - 1; ++k_neighbor)
    {
      // Get the cumulative probability range for the current neighbor
      const auto pi = cumulative_probability(i_compartment, k_neighbor);
      const auto pn = cumulative_probability(i_compartment, k_neighbor + 1);

      // Use of a Condition mask to avoid branching.
      // As the condition is not complex, ternary op manually guarantee that no
      // branching/warp divergence occurs
      next = (random_number <= pn && pi <= random_number)
                 ? i_neighbor(i_compartment,k_neighbor + 1)
                 : next;
    }

    return next; // Return the index of the chosen next compartment
  }*/

} // namespace Simulation::KernelInline

#endif
