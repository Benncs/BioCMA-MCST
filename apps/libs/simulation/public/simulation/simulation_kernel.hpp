#ifndef __SIMULATION_MC_KERNEL_HPP
#define __SIMULATION_MC_KERNEL_HPP

#include "Kokkos_Atomic.hpp"
#include <Kokkos_Core.hpp>
#include <Kokkos_Random.hpp>
#include <biocma_cst_config.hpp>
#include <cassert>
#include <common/kokkos_vector.hpp>
#include <mc/container_state.hpp>
#include <mc/events.hpp>
#include <mc/particles/data_holder.hpp>
#include <mc/particles/mcparticles.hpp>
#include <mc/prng/prng.hpp>
#include <simulation/alias.hpp>
#include <simulation/probability_leaving.hpp>
#include <simulation/probe.hpp>

static constexpr bool const_number_simulation = false;

namespace Simulation::KernelInline
{
  using GeneratorPool = Kokkos::Random_XorShift64_Pool<>;
  template <typename ListType> class Kernel
  {

  public:
    KOKKOS_FUNCTION void operator()(std::size_t i_particle) const;
    Kernel(double _d_t,

           ListType _list,
           ListType _extra,
           Kokkos::View<size_t, Kokkos::SharedSpace> _internal_counter_dead,
           Kokkos::View<MC::ContainerState*, Kokkos::SharedSpace> _local_compartments,
           NeighborsViewCompute _neighbors,
           DiagonalViewCompute _diag_transition,
           CumulativeProbabilityViewCompute _cumulative_probability,
           MC::EventContainer _events,
           ContributionView _biomass_contribution,
           LeavingFlowType _local_leaving_flow,
           LeavingFlowIndexType _local_index_leaving_flow,
           ProbeAutogeneratedBuffer prob,
           Kokkos::View<size_t, Kokkos::SharedSpace> _waiting_allocation_particle,
           GeneratorPool pool)
        : d_t(_d_t), list(_list), extra(std::move(_extra)),
          internal_counter_dead(std::move(_internal_counter_dead)),
          local_compartments(std::move(_local_compartments)), neighbors(std::move(_neighbors)),
          rng_pool(pool), diag_transition(std::move(_diag_transition)),
          cumulative_probability(std::move(_cumulative_probability)), events(std::move(_events)),
          biomass_contribution(std::move(_biomass_contribution)),
          local_leaving_flow(std::move(_local_leaving_flow)),
          local_index_leaving_flow(std::move(_local_index_leaving_flow)),
          probe_at_t(std::move(prob)),
          waiting_allocation_particle(std::move(_waiting_allocation_particle))
    {
    }

  private:
    double d_t{};
    ListType list;
    ListType extra;
    Kokkos::View<size_t, Kokkos::SharedSpace> internal_counter_dead;
    Kokkos::View<MC::ContainerState*, Kokkos::SharedSpace> local_compartments;
    NeighborsViewCompute neighbors;
    GeneratorPool rng_pool;
    DiagonalViewCompute diag_transition;
    CumulativeProbabilityViewCompute cumulative_probability;
    MC::EventContainer events;
    ContributionView biomass_contribution;
    LeavingFlowType local_leaving_flow;
    LeavingFlowIndexType local_index_leaving_flow;
    ProbeAutogeneratedBuffer probe_at_t;
    Kokkos::View<size_t, Kokkos::SharedSpace> waiting_allocation_particle;

    KOKKOS_INLINE_FUNCTION void handle_division(auto& particle) const
    {

      if (particle.properties.status == MC::CellStatus::CYTOKINESIS)
      {
        events.template incr<MC::EventType::NewParticle>();

        auto new_particle = particle.division(list.rng_instance);
        KOKKOS_ASSERT(new_particle.properties.status != MC::CellStatus::CYTOKINESIS);

        if constexpr (!const_number_simulation)
        {

          if (!extra.emplace(std::move(new_particle)))
          {
            Kokkos::printf("SPAWNING OVERFLOW\r\n");
            Kokkos::atomic_increment(&waiting_allocation_particle()); // TODO clean this
          }
        }
        else
        {
          particle.properties.weight *= 2;
          Kokkos::atomic_increment(
              &local_compartments(particle.properties.current_container).n_cells);
        }

        KOKKOS_ASSERT(particle.properties.status != MC::CellStatus::CYTOKINESIS);
      }
    }

    KOKKOS_INLINE_FUNCTION void handle_move(MC::ParticleDataHolder& properties) const;

    KOKKOS_INLINE_FUNCTION void handle_exit(auto& status, MC::ParticleDataHolder& properties) const
    {
      for (size_t i = 0LU; i < local_index_leaving_flow.size(); ++i)
      {
        // const double random_number = //local_rng.double_uniform();

        auto generator = rng_pool.get_state();
        const float random_number = generator.frand(0., 1.);
        rng_pool.free_state(generator);

        const auto& index = local_index_leaving_flow(i);
        const auto& flow = local_leaving_flow(i);
        if (properties.current_container != index || status != MC::CellStatus::IDLE)
        {
          return;
        }

        auto& current_container = local_compartments(index);
        if (probability_leaving(random_number, current_container.volume_liq, flow, d_t))
        {

          if constexpr (AutoGenerated::FlagCompileTime::use_probe)
          {
            // Ignore ret value, if probe is full were gonna miss events which is not really
            // important
            auto _ = probe_at_t.set(properties.hydraulic_time);
          }

          KOKKOS_ASSERT(Kokkos::atomic_load(&current_container.n_cells) > 0);
          Kokkos::atomic_sub(&current_container.n_cells, 1);
          properties.reset();
          status = MC::CellStatus::OUT;
        }
      }
    }

    [[nodiscard]] KOKKOS_INLINE_FUNCTION size_t __find_next_compartment(
        std::size_t i_compartment,
        double random_number,
        const Kokkos::View<const size_t*, Kokkos::LayoutStride, ComputeSpace>& i_neighbor) const;
  };

  /****************
  ** IMPL KERNEL **
  *****************/

  template <typename ListType>
  KOKKOS_FUNCTION void Kernel<ListType>::operator()(const std::size_t i_particle) const
  {

    auto& particle = list._owned_data[i_particle];
    auto& status = particle.properties.status;
    auto& properties = particle.properties;

    // // // TODO Test attribute
    if (status == MC::CellStatus::DEAD) [[unlikely]]
    {
      // This warp divergence is not a priori a problem because it is a
      // cold branch
      return;
    }

    handle_move(properties);

    handle_exit(status, properties);

    // // // Useless to try to reducing branhcing here because we're going to
    // // // early return so serializing will occur
    if (status == MC::CellStatus::OUT)
    {
      events.template incr<MC::EventType::Exit>();
      status = MC::CellStatus::DEAD;
      Kokkos::atomic_add(&internal_counter_dead(), 1);
      return;
    }

    particle.update(d_t, local_compartments(properties.current_container).concentrations, rng_pool);

    particle.contribution(biomass_contribution);

    handle_division(particle);
  }

  template <typename ListType>
  KOKKOS_INLINE_FUNCTION void
  Kernel<ListType>::handle_move(MC::ParticleDataHolder& properties) const
  {
    const size_t i_compartment = properties.current_container;
    auto& current_container = local_compartments(i_compartment);

    const auto i_neighbor = Kokkos::subview(neighbors, i_compartment, Kokkos::ALL);

    // Need 2 random numbers, use index 0 and 1 to acess to
    auto generator = rng_pool.get_state();
    const float rng1 = generator.frand(0., 1.);
    const double rng2 = generator.drand(0., 1.);
    rng_pool.free_state(generator);

    const bool mask_next = probability_leaving(
        rng1, current_container.volume_liq, diag_transition(i_compartment), d_t);

    if (mask_next)
    {
      const size_t next = __find_next_compartment(i_compartment, rng2, i_neighbor);
      Kokkos::atomic_sub(&current_container.n_cells, 1);
      Kokkos::atomic_add(&local_compartments(next).n_cells, 1);
      KOKKOS_ASSERT(Kokkos::atomic_load(&current_container.n_cells) > 0);
      properties.current_container = next;
      events.template incr<MC::EventType::Move>();
    }
  };

  /**
   * @brief Finds the next compartment for a particle based on a random number
   * and cumulative probabilities.
   *
   * This function determines the next compartment for a particle by comparing a
   * random number against the cumulative probabilities of the neighboring
   * compartments. It returns the index of the chosen next compartment based on
   * the transition probabilities.
   *
   * @param i_compartment Index of the current compartment.
   * @param random_number Random number used to decide the next compartment.
   * @param i_neighbor Span of indices representing neighboring compartments.
   * @param cumulative_probability 2D view of cumulative probabilities for the
   * compartments.
   *
   * @return The index of the next compartment for the particle.
   */
  template <typename ListType>
  KOKKOS_INLINE_FUNCTION size_t Kernel<ListType>::__find_next_compartment(
      const std::size_t i_compartment,
      const double random_number,
      const Kokkos::View<const size_t*, Kokkos::LayoutStride, ComputeSpace>& i_neighbor) const
  {
    const int max_neighbor = static_cast<int>(i_neighbor.size());
    size_t next = i_neighbor(0); // Default to the first neighbor
    // Iterate through the neighbors to find the appropriate next compartment
    for (int k_neighbor = 0; k_neighbor < max_neighbor - 1; ++k_neighbor)
    {
      // Get the cumulative probability range for the current neighbor
      const auto pi = cumulative_probability(i_compartment, k_neighbor);
      const auto pn = cumulative_probability(i_compartment, k_neighbor + 1);

      // Use of a Condition mask to avoid branching.
      // As the condition is not complex, ternary op manually guarantee that no
      // branching/warp divergence occurs
      next = (random_number <= pn && pi <= random_number) ? i_neighbor(k_neighbor + 1) : next;
    }

    return next; // Return the index of the chosen next compartment
  }

  // TODO CHECK IF WORTH IT
  /*
  template <typename ListType, typename ResultViewType>
  KOKKOS_INLINE_FUNCTION size_t
  Kernel<ListType, ResultViewType>::_find_next_compartment_2(
      const std::size_t i_compartment,
      const double random_number,
      const NeighborsViewCompute
          &i_neighbor) const
  {
    const int max_neighbor = static_cast<int>(i_neighbor.size());
    size_t next = i_neighbor(i_compartment,0); // Default to the first neighbor

    // Iterate through the neighbors to find the appropriate next compartment
    for (int k_neighbor = 0; k_neighbor < max_neighbor - 1; ++k_neighbor)
    {
      // Get the cumulative probability range for the current neighbor
      const auto pi = cumulative_probability(i_compartment, k_neighbor);
      const auto pn = cumulative_probability(i_compartment, k_neighbor + 1);

      // Use of a Condition mask to avoid branching.
      // As the condition is not complex, ternary op manually guarantee that no
      // branching/warp divergence occurs
      next = (random_number <= pn && pi <= random_number)
                 ? i_neighbor(i_compartment,k_neighbor + 1)
                 : next;
    }

    return next; // Return the index of the chosen next compartment
  }*/

} // namespace Simulation::KernelInline

#endif
