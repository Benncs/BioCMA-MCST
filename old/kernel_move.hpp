#ifndef __SIMULATION_MC_KERNEL_MOVE_HPP
#define __SIMULATION_MC_KERNEL_MOVE_HPP

#include <Kokkos_Core.hpp>
#include <Kokkos_Random.hpp>
#include <biocma_cst_config.hpp>
#include <cassert>
#include <mc/container_state.hpp>
#include <mc/events.hpp>
#include <mc/particles/data_holder.hpp>
#include <mc/particles/mcparticles.hpp>
#include <mc/prng/prng.hpp>
#include <simulation/alias.hpp>
#include <simulation/probe.hpp>
#include <type_traits>

static constexpr bool _use_kokkos_log = true;

namespace
{

  template <bool use_kokkos_log>
  KOKKOS_INLINE_FUNCTION typename std::enable_if<!use_kokkos_log, float>::type _ln(float x)
  {
    unsigned int bx = *reinterpret_cast<unsigned int*>(&x);
    const unsigned int ex = bx >> 23;
    const signed int t = static_cast<signed int>(ex) - static_cast<signed int>(127);
    unsigned int s = (t < 0) ? (-t) : t;
    bx = 1065353216 | (bx & 8388607);
    x = *reinterpret_cast<float*>(&bx);
    return -1.49278 + (2.11263 + (-0.729104 + 0.10969 * x) * x) * x + 0.6931471806 * t;
  }

  template <bool use_kokkos_log>
  KOKKOS_INLINE_FUNCTION typename std::enable_if<use_kokkos_log, float>::type _ln(float x)
  {
    return Kokkos::log(x);
  }

  KOKKOS_INLINE_FUNCTION bool
  probability_leaving(float random_number, double volume, double flow, double dt)
  {
    // return (dt * flow / volume) > (-_ln<_use_kokkos_log>(random_number));
    return (dt * flow ) > (-_ln<_use_kokkos_log>(random_number)*volume);
  }
} // namespace

namespace Simulation::KernelInline
{
  using GeneratorPool = Kokkos::Random_XorShift64_Pool<>;
  template <typename ListType> struct KernelMove
  {

    KernelMove(double _d_t,
               ListType _list,
               Kokkos::View<MC::ContainerState*, Kokkos::SharedSpace> _compartments,
               GeneratorPool pool,
               MC::EventContainer _events,
               NeighborsViewCompute _neighbors,
               CumulativeProbabilityViewCompute _cumulative_probability,
               DiagonalViewCompute _diag_transition,
               Kokkos::View<size_t, Kokkos::SharedSpace> _internal_counter_dead,
               ProbeAutogeneratedBuffer _probe_at_t,
               LeavingFlowType _local_leaving_flow,
               LeavingFlowIndexType _local_index_leaving_flow)
        : d_t(_d_t), list(std::move(_list)), local_compartments(std::move(_compartments)),
          rng_pool(pool), events(std::move(_events)), neighbors(std::move(_neighbors)),
          cumulative_probability(std::move(_cumulative_probability)),
          diag_transition(std::move(_diag_transition)),
          internal_counter_dead(std::move(_internal_counter_dead)),
          probe_at_t(std::move(_probe_at_t)), local_leaving_flow(std::move(_local_leaving_flow)),
          local_index_leaving_flow(std::move(_local_index_leaving_flow))
    {
    }
    KOKKOS_FUNCTION void operator()(std::size_t i_particle) const
    {
      auto& particle = list._owned_data[i_particle];
      auto& status = particle.properties.status;
      auto& properties = particle.properties;

      // // // TODO Test attribute
      if (status == MC::CellStatus::DEAD) [[unlikely]]
      {
        // This warp divergence is not a priori a problem because it is a
        // cold branch
        return;
      }

      handle_move(properties);

      handle_exit(status, properties);

      // // // Useless to try to reducing branhcing here because we're going to
      // // // early return so serializing will occur
      if (status == MC::CellStatus::OUT)
      {
        events.template incr<MC::EventType::Exit>();
        status = MC::CellStatus::DEAD;
        Kokkos::atomic_increment(&internal_counter_dead());
      }
    }

    KOKKOS_INLINE_FUNCTION void handle_move(MC::ParticleDataHolder& properties) const
    {
      
      const size_t i_compartment = properties.current_container;
      auto& current_container = local_compartments(i_compartment);

 
      auto generator = rng_pool.get_state();
      const float rng1 = generator.frand(0., 1.); //First prng to decide moving or not 
      rng_pool.free_state(generator);

      if (probability_leaving(
              rng1, current_container.volume_liq, diag_transition(i_compartment), d_t))
      {

        auto generator = rng_pool.get_state();
        const double rng2 = generator.drand(0., 1.); //Second prng to select target container 
        rng_pool.free_state(generator);

        const size_t next = __find_next_compartment(i_compartment, rng2);
        KOKKOS_ASSERT(Kokkos::atomic_load(&current_container.n_cells) > 0); // ??
        // Kokkos::atomic_decrement(&current_container.n_cells);
        // Kokkos::atomic_increment(&local_compartments(next).n_cells);
        properties.current_container = next;
        events.template incr<MC::EventType::Move>();
      }
    }
    
     /**
   * @brief Finds the next compartment for a particle based on a random number
   * and cumulative probabilities.
   *
   * This function determines the next compartment for a particle by comparing a
   * random number against the cumulative probabilities of the neighboring
   * compartments. It returns the index of the chosen next compartment based on
   * the transition probabilities.
   *
   * @param i_compartment Index of the current compartment.
   * @param random_number Random number used to decide the next compartment.
   * @param i_neighbor Span of indices representing neighboring compartments.
   * @param cumulative_probability 2D view of cumulative probabilities for the
   * compartments.
   *
   * @return The index of the next compartment for the particle.
   */
    [[nodiscard]]KOKKOS_INLINE_FUNCTION size_t __find_next_compartment(
        const std::size_t i_compartment,
        const double random_number) const
    {
      const int max_neighbor = static_cast<int>(neighbors.extent(1));
      size_t next = neighbors(i_compartment,0); // Default to the first neighbor
      // Iterate through the neighbors to find the appropriate next compartment
      for (int k_neighbor = 0; k_neighbor < max_neighbor - 1; ++k_neighbor)
      {
        // Get the cumulative probability range for the current neighbor
        const auto pi = cumulative_probability(i_compartment, k_neighbor);
        const auto pn = cumulative_probability(i_compartment, k_neighbor + 1);

        // Use of a Condition mask to avoid branching.
        // As the condition is not complex, ternary op manually guarantee that no
        // branching/warp divergence occurs
        next = (random_number <= pn && pi <= random_number) ? neighbors(i_compartment,k_neighbor + 1) : next;
      }

      return next; // Return the index of the chosen next compartment
    }

    KOKKOS_INLINE_FUNCTION void handle_exit(auto& status, MC::ParticleDataHolder& properties) const
    {
      for (size_t i = 0LU; i < local_index_leaving_flow.size(); ++i)
      {
        // const double random_number = //local_rng.double_uniform();

        auto generator = rng_pool.get_state();
        const float random_number = generator.frand(0., 1.);
        rng_pool.free_state(generator);

        const auto& index = local_index_leaving_flow(i);
        const auto& flow = local_leaving_flow(i);
        if (properties.current_container != index || status != MC::CellStatus::IDLE)
        {
          return;
        }

        auto& current_container = local_compartments(index);
        if (probability_leaving(random_number, current_container.volume_liq, flow, d_t))
        {

          if constexpr (AutoGenerated::FlagCompileTime::use_probe)
          {
            // Ignore ret value, if probe is full were gonna miss events which is not really
            // important
            auto _ = probe_at_t.set(properties.hydraulic_time);
          }

          KOKKOS_ASSERT(Kokkos::atomic_load(&current_container.n_cells) > 0);
          Kokkos::atomic_decrement(&current_container.n_cells);
          // clearState(MC::CellStatus::OUT);
          properties.reset();
          status = MC::CellStatus::OUT;
        }
      }
    }

    double d_t;
    ListType list;
    Kokkos::View<MC::ContainerState*, Kokkos::SharedSpace> local_compartments;
    GeneratorPool rng_pool;
    MC::EventContainer events;
    NeighborsViewCompute neighbors;
    CumulativeProbabilityViewCompute cumulative_probability;
    DiagonalViewCompute diag_transition;
    Kokkos::View<size_t, Kokkos::SharedSpace> internal_counter_dead;
    ProbeAutogeneratedBuffer probe_at_t;
    LeavingFlowType local_leaving_flow;
    LeavingFlowIndexType local_index_leaving_flow;
  };
} // namespace Simulation::KernelInline

#endif //!__SIMULATION_MC_KERNEL_MOVE_HPP


  // TODO CHECK IF WORTH IT
  /*
  template <typename ListType, typename ResultViewType>
  KOKKOS_INLINE_FUNCTION size_t
  Kernel<ListType, ResultViewType>::_find_next_compartment_2(
      const std::size_t i_compartment,
      const double random_number,
      const NeighborsViewCompute
          &i_neighbor) const
  {
    const int max_neighbor = static_cast<int>(i_neighbor.size());
    size_t next = i_neighbor(i_compartment,0); // Default to the first neighbor

    // Iterate through the neighbors to find the appropriate next compartment
    for (int k_neighbor = 0; k_neighbor < max_neighbor - 1; ++k_neighbor)
    {
      // Get the cumulative probability range for the current neighbor
      const auto pi = cumulative_probability(i_compartment, k_neighbor);
      const auto pn = cumulative_probability(i_compartment, k_neighbor + 1);

      // Use of a Condition mask to avoid branching.
      // As the condition is not complex, ternary op manually guarantee that no
      // branching/warp divergence occurs
      next = (random_number <= pn && pi <= random_number)
                 ? i_neighbor(i_compartment,k_neighbor + 1)
                 : next;
    }

    return next; // Return the index of the chosen next compartment
  }*/